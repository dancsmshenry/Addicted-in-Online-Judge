# 目录



### 442、数组中的重复数据

- （每个元素都放到其对应的位置，如果发现对应位置和当前的位置的数都是一样的话，就把它记录下来（因为他出现了两次），并把其中一个设为n+1，这样下次就不会重复记录这个数了）
- 多看！多看！多看！

- ```cpp
  class Solution {
  public:
      vector<int> findDuplicates(vector<int>& nums) {
          vector<int> res;
          int n = nums.size();
  
          for (int i = 0; i < n; ++ i) {
              while (nums[i] < n + 1 && nums[nums[i] - 1] != nums[i]) {
                  // 判断小于n+1是因为如果为n+1的话，就代表已经处理过了，就不需要处理了
                  // 第二个条件是判断应该放的位置是不是当前的数字，如果不是，就交换并继续循环；否则就退出循环
                  swap(nums[nums[i] - 1], nums[i]);
              }
  
              if (nums[i] < n + 1 && nums[nums[i] - 1] == nums[i] && nums[i] - 1 != i) {
                  // 判断小于n+1是因为如果为n+1的话，就代表已经处理过了，就不需要处理了
                  // 第二个条件是判断当前元素是否重复，如果重复就继续
                  // 第三个条件是排除自己和自己相比较的q
                  res.push_back(nums[i]);
                  nums[nums[i] - 1] = n + 1;
                  nums[i] = n + 1;
              }
          }
  
          return res;
      }
  };
  ```





### 41、缺失的第一个正数

- 原地hash
- 每个数都移动到其对应的下标+1的位置（移动的前提：该数大于0，小于n，nums[i] != nums[nums[i]-1]，这是为了防止出现两个位置的数都一样导致无限交换的情况）
- 然后再遍历一遍，如果当前的数字不等于当前的下标+1，那么下标+1就是缺失的第一个正数
- 解析：很关键的一点是交换，即对于nums[i]，如果值是在1-n之间的，我就把它放到nums[nums[i] - 1]的位置，然后把nums[num[i] - 1]的值放到nums[i]的位置，一直反复上面的操作，直到两者相同；然后继续操作下一个元素
- 最后从头开始遍历，如果元素下标和值不符合的话，就返回下标+1
- 字节面试变种题目：
  - 在leetcode41的基础上，找出大于k的不在数组中的最小正整数（solve：把所有的数字都-k，如果全都是负数，就返回k+1，否则就和41题一样处置）





### 剑指03、数组中的重复的数字

- 这道题也是原地hash
- 解析：对于每个数nums[i]，如果和nums[nums[i]]相等，就返回数字，否则就进行交换





