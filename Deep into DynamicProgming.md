# 目录

### Stock Problem

- 买卖股票的最佳时机I
- 买卖股票的最佳时机II
- 买卖股票的最佳时机III
- 买卖股票的最佳时机IV
- 最佳买卖股票时机含冷冻期
- 买卖股票的最佳时机含手续费



### Knapsack Problem

- 01背包问题
- 完全背包问题
- 多重背包问题
- 混合背包问题
- 二维费用背包问题
- 分组背包问题
- 背包问题求方法数
- 单词拆分

 

### House Robber

- 打家劫舍I
- 打家劫舍II
- 打家劫舍III



### 区间型dp

- 戳气球
- 单词拆分
- 最长回文子串
- 647、回文子串



### 序列型dp

- 正则表达式
- 编辑距离



### 传统dp

- 最长子序列
- 零钱兑换
- 爬楼梯
- 斐波那契数列
- 不同路径
- 最小路径和
- 最小三角路径和



### Others

- 接雨水
- 俄罗斯套娃信封问题
- 鸡蛋掉落
- 剑指offer n个骰子的点数
- 最长重复子数组（这么经典的dp我居然没看出来......）
- 53、最大子序列和（剑指offer 42.连续子数组的最大和）
  - 简单题，但是思路却很巧妙
  - 先初始化dp为第一个元素
  - 对于后面的每一个元素，如果我当前的dp是正的话，那我就加上当前的数；否则dp就变为当前的数（这一步非常的关键，可以认为是一种贪心的做法，因为dp为正的时候，它可以搏一搏更大的数，因为后面如果是正的，就更大了；如果负的，那么首先res已经记录了max值，其次，加上负的，有可能后面还会有更大的数。这无疑是一种贪心了）
  - 然后将此时的dp和res进行比较，res去max
  - 最后遍历完所有的元素后，return res



# 总结

- 题目如果涉及到区间的，马上想到区间型动态规划
  - 解：首先是确定区间i-j，然后在i-j里面选择数字k，查看i-k和k+1-j的情况，然后把状态转移给i-j
  - 注意要控制好循环的边界，同时做好dp数组的初始化
- 而区间型的dp，看看是否可以用背包问题来优化一下
  - 例如单词拆分，用区间是可以做出来，但是时间空间的效率都太慢了
  - 所以思考一下对于0-i之间的字母，如果可以用dictionary组合出来，必然存在j，使得j-i之间为一个在dictionary里面的单词
  - 而要保证0-i之间为true，就要保证后面是一个单词，并且前面也要是true
  - 这就是最早的硬币问题啦
- 而股票问题给我们最大的启示就是
  - 首先，要找到正确的状态去转移，题目往往会给很多无用的信息
  - 如果状态的维数太高，考虑是不是要降维换成数组来表示（如三维数组变为sold和hold两个数组）



### 滚动数组优化

- 思路：可以用first和second，或者temp来实现，或者使用二进制来实现
- 例题：
  - 62、不同路径
  - 63、不同路径II
  - 64、最小路径和
  - 120、最小三角路径和
  - 198、打家劫舍
  - 213、打家劫舍II（这里只能用第一种方法来实现滚动数组，小心坑）
