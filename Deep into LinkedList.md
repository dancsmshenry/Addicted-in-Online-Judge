# 目录

## 链表的基本操作

### 链表合并

- 简述：将两个链表合并为一个链表，可以通过递归实现，也可以逐个逐个点的合并
- 例题：
  - 21、合并两个有序链表（可以一个一个节点的合并，也可以用递归合并）



### 链表反转

- 简述：将链表的节点反转，可以通过递归实现，也可以逐个逐个点的反转
- 例题：
  - 25、k个一组反转链表
    - 有两个思路：先计算出链表的长度，减去长度mod k；然后，从头开始遍历，有一个count计数，count小于k就只是单纯的反转，等于k，就把整个区间反转，然后count设为1
    - 第二个思路就非常的巧妙了，把整个函数都设为递归，先遍历头节点开始的前k个（其中如果出现nullptr，就表明当前区间的长度小于k），然后开始反转，因为反转了以后，此时的head其实就是最后一个节点，然后head->next再调用依次函数，最后返回
  - 92、反转链表II（和25一样，都是要反转指定范围的链表）
  - 24、两两交换链表中的节点（可以逐个逐个点反转，也可以递归实现）
  - 206、反转链表



### 快慢指针

- 简述：快慢指针分为两种

  - 第一种是一个指针走一步，另一个指针走多步（比如说找链表的中点）
  - 第二种是一个指针先走多步，然后两个指针再同时开始走（比如说找链表的倒数第几个点）

- 写法：

  - ```cpp
    //slow在奇数的时候指向中点，在偶数的时候指向后半段开始的地方
    //fast在奇数的时候指向最后一个节点，在偶数的时候指向nullptr
    ListNode *fast = head, *slow = head;
    while (fast && fast -> next) {
        fast = fast -> next -> next;
        slow = slow -> next;
    }
    ```

- 例题：

  - 19、删除链表的第N个结点（快慢指针找到删除节点）
  - 61、旋转链表（先统计长度，然后快慢指针，慢指针指向要被旋转的起点，快指针指向终点，然后穿针引线即可）
  - 141、环形链表（快慢指针，相同就代表有环）
  - 234、回文链表（快慢指针找到中点，找的同时反转链表）
  - 142、环形链表II（有一种快慢指针的写法，很巧妙）
  - 剑指offer22、链表中倒数第k个节点（快慢指针找到倒数第k个节点）





## 其他

### 哈希表

- 141、环形链表（用哈希表记录node，如果有重复就有环）
- 142、环形链表II
- 剑指offer II 022.链表中环的入口节点



### 栈

- 445、两数相加II（很经典的链表题，可以模拟，也可以用栈来实现）







## 链表的进阶操作

### 链表排序

- 23、合并K个升序链表（归并排序，自顶向下或自下向上都行）

- 148、排序链表（链表的归并排序）
- 147、对链表进行插入排序（模拟插入排序）



### 模拟

- 143、重排链表
  - 先用快慢指针找到链表的中点，然后对链表的后半部分进行反转，然后就是头尾指针进行交替插入数据，你一个我一个
- 字节高频题
  - 排序奇升偶降的链表
  - https://blog.csdn.net/qq_26733783/article/details/110161163
  - 具体思路：先将链表根据奇数和偶数分割开来，得到两个链表，然后对降序的那个链表进行反转，最后问题就转化为合并两个有序链表了
- 86、分隔链表
  - 将大于等于x的节点都放到另一个链表上，原链表跳过该点；最后合并即可
- 328、奇偶链表
  - 感觉很难看懂，需要多次反复观摩，非常非常的麻，根本找不到一个非常好的办法来解决问题.......
- 剑指offer35 复杂链表的复制（复制带随机指针的链表）
  - 官方给的题解：用哈希表，key记录原链表的结点，value记录新链表的结点
  - 然后对于每个点进行排查，如果他的原节点出现在hash中，就代表它的新结点被创建了，就不用继续往下找，返回hash[head]
  - 如果没有，那么，就创建新节点，加入到hash中，然后该新节点的next和random就继续调用该函数回溯
  - 总结：官方给的题解思路清晰，代码量短，很适合记忆
  - 我给的题解：用hash，key存储结点的坐标（从0->1开始计数），value记录Node*
  - 准备：用一个空结点指向链表
  - 先进行第一次遍历，对于hash，记录下每个点的坐标以及新的Node*；同时res往后移位（即先把next给全部连接上）
  - 然后再进行依次补上random
  - （这个方法是一个bug，因为他这里的head1 -> random -> val返回的是点的下标，而不是点的val。。。。。。。）





# 总结

- 删除节点的时候必须加上dummy节点，因为如果是删除第一个节点的话，会不好处理
- 要注意快慢指针因为长度的奇偶不同导致的差异
- 学会链表合并和链表反转的递归写法
