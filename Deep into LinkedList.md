# 目录

## 链表的基本操作

### 链表合并

- 简述：将两个链表合并为一个链表，可以通过递归实现，也可以逐个逐个点的合并
- 例题：
  - 21、合并两个有序链表（可以一个一个节点的合并，也可以用递归合并）





### 链表反转

- 简述：将链表的节点反转，可以通过递归实现，也可以逐个逐个点的反转
- 例题：
  - 25、k个一组反转链表
    - 有两个思路：先计算出链表的长度，减去长度mod k；然后，从头开始遍历，有一个count计数，count小于k就只是单纯的反转，等于k，就把整个区间反转，然后count设为1
    - 第二个思路就非常的巧妙了，把整个函数都设为递归，先遍历头节点开始的前k个（其中如果出现nullptr，就表明当前区间的长度小于k），然后开始反转，因为反转了以后，此时的head其实就是最后一个节点，然后head->next再调用依次函数，最后返回
  - 92、反转链表II（和25一样，都是要反转指定范围的链表）
  - 24、两两交换链表中的节点（可以逐个逐个点反转，也可以递归实现）
  - 206、反转链表
    - 学会递归和非递归的写法（非常的巧妙的递归写法，真的要好好看看）





### 快慢指针

- 简述：快慢指针分为两种

  - 第一种是一个指针走一步，另一个指针走多步（比如说找链表的中点）
  - 第二种是一个指针先走多步，然后两个指针再同时开始走（比如说找链表的倒数第几个点）

- 写法：

  - ```cpp
    //	写法一
    //	slow在奇数的时候指向中点，在偶数的时候指向后半段开始的地方
    //	fast在奇数的时候指向最后一个节点，在偶数的时候指向nullptr
    ListNode *fast = head, *slow = head;
    while (fast && fast -> next) {
        fast = fast -> next -> next;
        slow = slow -> next;
    }
    
    //	写法二
    //	这种写法必然保证了slow最后的位置，是在后半段开始的前面一个点
    //	比如 1 2 3 4，则此时会停留在2的位置
    //	比如 1 2 3 4 5，则此时会停留在3的位置
    ListNode *slow = head, *fast = head;
    while (slow && fast -> next && fast -> next -> next) {
        slow = slow -> next;
    	fast = fast -> next -> next;
    }
    ```

- 例题：

  - 19、删除链表的第N个结点（快慢指针找到删除节点）
  - 61、旋转链表（先统计长度，然后快慢指针，慢指针指向要被旋转的起点，快指针指向终点，然后穿针引线即可；这里比较坑的地方就是他给定的k可能会长于原链表的长度的..，所以要先求出链表的长度，再对k进行求余）
  - 141、环形链表（快慢指针，相同就代表有环，需要注意快慢指针能相遇的证明）
  - 234、回文链表（快慢指针找到中点，找的同时反转链表）
  - 142、环形链表II（有一种快慢指针的写法，很巧妙）
  - 876、链表的中间结点（快慢指针，慢指针最后指向的就是中间节点）
  - 剑指offer22、链表中倒数第k个节点（快慢指针找到倒数第k个节点）





## 其他

### 哈希表

- 141、环形链表（用哈希表记录node，如果有重复就有环）
- 142、环形链表II
- 剑指offer II 022.链表中环的入口节点





### 栈

- 445、两数相加II（很经典的链表题，可以模拟，也可以用栈来实现）







## 链表的进阶操作

### 链表排序

- 23、合并K个升序链表（归并排序，自顶向下或自下向上都行）
- 148、排序链表（链表的归并排序）
- 147、对链表进行插入排序（模拟插入排序）
- 剑指offer II 077.链表排序（注意自顶向下的链表排序）





### 链表操作组合拳

#### 143、重排链表

- 先用快慢指针找到链表的中点，然后对链表的后半部分进行反转，然后就是头尾指针进行交替插入数据，你一个我一个
- 思路一定要清晰



字节高频题
- 排序奇升偶降的链表
- https://blog.csdn.net/qq_26733783/article/details/110161163
- 具体思路：先将链表根据奇数和偶数分割开来，得到两个链表，然后对降序的那个链表进行反转，最后问题就转化为合并两个有序链表了



#### 86、分隔链表

- 将大于等于x的结点放到另一个链表中，同时在原链表中调整next指针的指向，最后合并链表即可



#### 328、奇偶链表

方法一

- 用一个dummy指针指向奇数位置结点的链表，用oushu指针指向偶数结点的链表，每次都把下一个结点（即偶数结点）给放到偶数链表后面
- 最后让奇数链表后面接上偶数链表即可
  - 有一个陷阱，就是如何找到奇数链表的最后一个结点呢？因为我们判断的时候是head && head -> next的，就head可能是nullptr
  - 所以每次都需要用一个tail结点，去记录当前的最后一个结点，即判断此时的head和head -> next谁不是空



方法二

- 最开始先保证链表最少有一个结点
- 然后让node1变为第二个结点（后续用这个链表存储偶数结点），然后node2变为第一个结点（用来存储奇数结点）
- 注意，这里需要移动的结点实际上是node2和node1，但是后续要把node1给接入到奇数链表结点的后面，所以要新设一个node3的结点，代替node1用来移动
- PS：这是题解给的最好的方法





#### 剑指offer35 复杂链表的复制

- 官方给的题解：用哈希表，key记录原链表的结点，value记录新链表的结点
- 然后对于每个点进行排查，如果他的原节点出现在hash中，就代表它的新结点被创建了，就不用继续往下找，返回hash[head]
- 如果没有，那么，就创建新节点，加入到hash中，然后该新节点的next和random就继续调用该函数回溯
- 总结：官方给的题解思路清晰，代码量短，很适合记忆
- 我给的题解：用hash，key存储结点的坐标（从0->1开始计数），value记录Node*
- 准备：用一个空结点指向链表
- 先进行第一次遍历，对于hash，记录下每个点的坐标以及新的Node*；同时res往后移位（即先把next给全部连接上）
- 然后再进行依次补上random
- （这个方法是一个bug，因为他这里的head1 -> random -> val返回的是点的下标，而不是点的val。。。。。。。）







# 总结

- 删除节点的时候必须加上dummy节点，因为如果是删除第一个节点的话，会不好处理
- 要注意快慢指针因为长度的奇偶不同导致的差异
- 学会链表合并和链表反转的递归写法
