# 目录

### hash表+前缀和

- 560、和为k的子数组（看起来是easy题目，但是实现的非常的巧妙，要重点看！）
  - 剑指offer II 010.和为 k 的子数组
  - 非常巧妙的一种思路，从前往后使用前缀和 和 哈希表，如果存在count - k就加起来，然后把当前的count放入hashmap中
  - 这里有一个坑爹的细节，就是当count等于k的时候，要去hashmap中查找0，此时的话0必须要先设为1（这也导致我之前一直没写出来的原因之一）
- 525.连续数组（同样也是用哈希表和前缀和实现的）
  - 剑指offer II 011.0 和 1 个数相同的子数组
- 724.寻找数组的中心下标
- 1991.找到数组的中间位置



### hash表

- 128、最长连续序列
  - 挺有趣的一道题，用hashmap记录了数组元素以后，每次以当前位置为连续序列的最低点，往后找
  - 同时事件时间复杂度最多o(n)
- 剑指offer II 016.不含重复字符的最长子字符串（经典老题）





### 原地hash

442、数组中的重复数据

- （每个元素都放到其对应的位置，如果发现对应位置和当前的位置的数都是一样的话，就把它记录下来（因为他出现了两次），并把其中一个设为n+1，这样下次就不会重复记录这个数了）

- 多看！多看！多看！

- ```cpp
  class Solution {
  public:
      vector<int> findDuplicates(vector<int>& nums) {
          vector<int> res;
          int n = nums.size();
  
          for (int i = 0; i < n; ++ i) {
              while (nums[i] < n + 1 && nums[nums[i] - 1] != nums[i]) {
                  // 判断小于n+1是因为如果为n+1的话，就代表已经处理过了，就不需要处理了
                  // 第二个条件是判断应该放的位置是不是当前的数字，如果不是，就交换并继续循环；否则就退出循环
                  swap(nums[nums[i] - 1], nums[i]);
              }
  
              if (nums[i] < n + 1 && nums[nums[i] - 1] == nums[i] && nums[i] - 1 != i) {
                  // 判断小于n+1是因为如果为n+1的话，就代表已经处理过了，就不需要处理了
                  // 第二个条件是判断当前元素是否重复，如果重复就继续
                  // 第三个条件是排除自己和自己相比较的q
                  res.push_back(nums[i]);
                  nums[nums[i] - 1] = n + 1;
                  nums[i] = n + 1;
              }
          }
  
          return res;
      }
  };
  ```







41、缺失的第一个正数

- 每个数都移动到其对应的下标+1的位置（移动的前提：该数大于0，小于n，nums[i] != nums[nums[i]-1]，这是为了防止出现两个位置的数都一样导致无限交换的情况）
- 然后再遍历一遍，如果当前的数字不等于当前的下标+1，那么下标+1就是缺失的第一个正数
- 解析：很关键的一点是交换，即对于nums[i]，如果值是在1-n之间的，我就把它放到nums[nums[i] - 1]的位置，然后把nums[num[i] - 1]的值放到nums[i]的位置，一直反复上面的操作，直到两者相同；然后继续操作下一个元素
- 最后从头开始遍历，如果元素下标和值不符合的话，就返回下标+1
- 字节面试变种题目：
  - 在leetcode41的基础上，找出大于k的不在数组中的最小正整数（solve：把所有的数字都-k，如果全都是负数，就返回k+1，否则就和41题一样处置）







剑指03、数组中的重复的数字

- 对于每个数nums[i]，如果和nums[nums[i]]相等，就返回数字，否则就进行交换