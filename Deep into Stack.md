# 目录

- 946.验证栈序列/剑指 Offer 31. 栈的压入、弹出序列
  - 模拟栈的操作
    - 如果当前的栈顶等于弹出顺序的，就弹出此时的栈顶，同时将指向弹出顺序的指针往后移一位
    - 如果不等于，就把压入序列的元素继续弹入
  - 什么时候退出
    - 压入和弹出队列的元素都全被用完的时候，退出while循环，返回true
    - 压入队列的元素都放入了栈中，但是弹出序列还有未被遍历的元素，返回false
- 下一个更大元素
  - 维护一个栈，栈内的元素越往上越小，如果新进来的元素比栈顶的元素大，就记录到hashmap中
- 最长有效括号
  - 维护一个栈，栈储存的是字符串的坐标，新来的元素如果是（，就放进去；如果有），就更新result，同时把（，踢出去
- 下一个更大元素II
  - 维护一个栈，栈内的元素越往上越小，如果新来的元素大于栈顶元素，就pop同时记录到数组中
  - 注意，栈内储存的是数组的下标
  - 这道题如果当前元素后面没有比它大的话，就要再从前往后帮他找一遍（所以只有最大的元素才是-1）
- 二叉树的前中后序遍历，用栈来实现
  - 这里先写一下栈和递归之间的关系：递归，顾名思义，会出现在自己这个函数中调用自己的情况，那么就是说，我要结果，我就要再调用一遍这个函数，得到另一个结果，然后才能推导出当前的结果；也所以，递归就需要有一个边界条件去防止无限的递归
  - 这样就有点像栈，要算A，就要先算B；要算B，就要先算C。就是最先要计算的，是最后才计算出来的；而最后面提出来要计算的，是立刻能计算出来的
  - 所以，对于二叉树的各种遍历，其实是可以用栈模拟出来的



# 总结

- 遇到一个数组中，需要维护最大最小值（或者是比前一个大，比前一个小）的，就可以维护一个栈