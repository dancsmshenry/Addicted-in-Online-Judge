# 目录

## 剑指offer II 041 滑动窗口的平均值

- 用一个队列来维护，如果放入的数字的数量超过了n，就把元素给踢出，然后重新计算avg







## 380.O(1) 时间插入、删除和获取随机元素

- hashmap+array实现（array存放数字，hashmap存放每个数字对应的下标）
  - 随机返回：随机返回数组下标即可
  - 增加：在array后面添加一个数字，hashmap存放数字的下标
  - 删除：根据被删除元素找到数字的下标，再回到原数组，将最后一个数字和被删除数字交换，最后一个数字设为0，容量减一

- 剑指offer II 030. 插入、删除和随机访问都是 O(1) 的容器







## cpp实现hashmap







## 实现并发的bitmap

- 我用了32位的int数组实现，Set来一个key，计算它对应哪个int（idx=key/32），然后把这个array[idx]第（bit=key%32）位置为1即可，Test的时候类似，返回那个bit是否为1
- 然后操作前加锁，操作后解锁







## 最快速度求两个数组（或是set）的交集

- 方法一：暴力，一个数组做外循环，另一个数组做内循环，暴力枚举，时间是O(N^2)
- 方法二：将两个数组进行预处理排序（当然如果是std::set的话，本身就是有序的，就没事了），然后用双指针，时间是O(nlogn)
- 方法三：将两个数组的数据全部映射到一个比较大的数组里面，数组的值记录当前元素出现了多少次，如果出现了两次及以上的就是answer，时间是O（N+N），不过这需要很大的空间去容纳数据
- 方法四：先将一个数组的元素映射到hash表中，然后再将另一个数组的元素也映射进去，接着记录，发生了hash碰撞的就代表是交集，这比方法三好一点的地方是空间不一定很大，可以利用hash来解决