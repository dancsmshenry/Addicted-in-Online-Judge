# 目录

### 二叉树的基本性质

- 思路：
  - 二叉搜索树的基本性质，二叉树前中后序遍历的特性，完全二叉树的性质
  - 从前中遍历或中后遍历能够推出二叉树

- 模板：
  - 

- 例题：
  - 101、对称二叉树（两边dfs）
  - 104、二叉树的最大深度
  - 105、从前序与中序遍历序列构造二叉树（维护两边界即可）
  - 572、另一棵树的子树（对子树要有清晰的认识）
  - 671、二叉树中第二小的节点（读题仔细，dfs解决，老套路了）
  - 236、二叉树的最近公共祖先（先判断当前的节点是不是目标节点之一（或者是不是nullptr），如果是就直接返回；否则就判断左边和右边，如果左边是空的，那就证明必然是右边，反之也是一样，如果两边都不是空的话，就代表两个节点在当前节点的两侧，直接返回当前节点）
  - 124、二叉树的最大路径和
    - 对于一个二叉树的路径，对于一个点，无非就两种情况，第一种：从该点出发，只走左子树或右子树
    - 第二种：从左子树的某一处出发，经过该节点，然后到达右子树的某一处
    - 思路由此就出来了：设置全局变量maxn，设最开始的maxn为root -> val（如果nullptr就返回0）
    - 然后对该点进行遍历，走左边的最大值是多少，走右边的最大值是多少（注意，这里如果得到的是负数的话，就不应该走，就应该为0），然后，得到max1 = left + right + root -> val；
    - max1和maxn进行比较
    - 不过这个函数的精髓是，在探究走左子树的时候，就solve(root -> left)，右子树同理，即走左子树的时候，就考虑过了以左子树根节点为根节点的时候需要考虑的情况了
    - 同时最后返回的还是一个root -> val + max(left, right)，这里是max，是因为当别人调用你这个函数的时候，是以别人的结点为根节点出发的，所以你只能选择走左边或右边（也就是说，只有自己是根节点的时候，才能比较同时走左右两边的情况）
  - 剑指offer 26 树的子结构（对于每个点都判断是否为目标二叉树，注意这里树的子结构和树的子树是不一样的、、、、）






### 层序遍历

- 思路：
  - 需要对树进行层序遍历，也可以认为是要进行广度优先搜索，在层序遍历的时候进行其他的操作

- 模板：
  - 建立一个queue（队列），最开始第一个root点放入队列，进行我们想要的操作（求最大值求平均值求最左边的数），注意此时一开始是用一个node1来接住这个点，然后把这个点给pop；操作完后，就把该点的左右结点给放入队列中，依次操作
  - 踩坑：注意，for循环的是一开始队列的大小size，否则的话，后续的元素不断放入，size会改变的

- 例题：
  - 102、二叉树的层序遍历（层序遍历）
  - 515、在每个树行中找最大值（层序遍历，记录max）
  - 429、N叉树的层序遍历（层序遍历）
  - 637、二叉树的层平均值（层序遍历，求平均值）
  - 199、二叉树的右视图（层序遍历，每次只取最后一个数）
  - 103、二叉树的锯齿形层序遍历（层序遍历，根据深度反转数组）
  - 958、二叉树的完全性检验（层序遍历，根据完全二叉树的性质，一旦遇到nullptr，后面就不应该有节点了，否则就不是完全二叉树）
  - 513、找树左下角的值（层序遍历，记录每次出现的第一个值）
  - 222、完全二叉树的节点个数（层序遍历，遇到nullptr就返回答案）
  - 1609、奇偶树（层序遍历，再根据每一层做不同的处理）
  - 面试题 04.03、 特定深度节点链表（层序遍历生成链表）
  - 剑指offer 32、从上到下打印二叉树（层序遍历组合拳）





### 前中后序遍历

- 思路：
  - 需要对树进行根左右，左根右，左右根的遍历，然后每次遍历的时候会进行一些其他的操作

- 模板：
  - 遍历一般有两种方式来实现，第一种是递归，第二种是用栈模拟递归（挖坑：第三种遍历mirror不会，后续填坑）

- 例题：
  - 144、二叉树的前序遍历（递归/非递归版）
  - 145、二叉树的后序遍历（递归/非递归版）
  - 98、验证二叉搜索树
    - 这道题是用到了二叉搜索树的性质+中序遍历。即对于每棵树，根节点是大于左子树的节点的，右子树的节点是大于根节点的
    - 然后联想到中序遍历是左根右的，所以就一方面维护一个pre节点，另一方面左根右的遍历，走完左子树，pre就变为左子树中的最大值（即左子树的右子树其中一个值），和根节点比较；走完根节点，pre就变为根节点，和右子树的左子树的最小值（即右子树的左子树其中一个值）进行比较）
    - 这就是中序遍历的高深之处，始终维护着pre为一部分的最大值
    - 这道题的做法无非就是中序遍历的变种（第一种是每次遍历都维护前面一个节点，第二种是递归得到全部的数组，第三种是stack维护前一个节点）
  - 590、N叉树的后序遍历（换汤不换药啊）
  - 剑指offer36（这道题非常的经典，需要好好的思考一下）
  - 872、叶子相似的树（非常巧妙地中序遍历输出叶子，然后对比）
  - 589、N叉树的前序遍历（也是换汤不换药啊）
  - 二叉树的下一个节点（利用中序遍历，如果有右子树，就往右子树下面找，否则就往上找）





### 二叉搜索树

- 思路：
  - 二叉搜索树的性质：中序遍历得到的数组是依次递增的，右左根得到的数组是依次递减的，当前节点的数字是大于左边而小于右边的
- 模板：
  - 中序遍历或者是右左根遍历，都可以用递归或stack来实现
- 98、验证二叉搜索树（利用二叉搜索树的性质）
- 109、有序链表转换二叉搜索树（经典利用二叉搜索树的性质）
- 530、二叉搜索树的最小绝对差（二叉搜索树的性质，中序遍历）
- 783、二叉搜索树节点最小距离（同上）
- 897、递增顺序搜索树（利用二叉搜索树性质中序遍历建树）
- 938、二叉搜索树的范围和（利用二叉搜索树性质）
- 235、二叉搜索树的最近公共祖先
  - 通过大小判断接下来遍历那一边的子树
- 450、删除二叉树中的节点（非常经典的题目，代码里面有注释，感觉会很常考）
- 701、二叉搜索树中的插入操作（二叉搜索树的性质）
- 98、验证二叉搜索树（利用二叉搜索树的性质，中序遍历得到的数组应该是一个递增的数组，如果不是就返回false）
- 108、将有序数组转换为二叉搜索树（经典传递数组和数组边界，然后递归）
- 剑指offer 54、 二叉搜索树的第k大节点
  - 非递归的做法（右左根依次遍历，得到便是依次递减的数列，同时统计k的值即可）
  - 递归的做法（递归实现右左根遍历）
- 剑指offer 33、二叉搜索树的后序遍历
  - 经典传递数组边界
- 剑指offer 36、二叉搜索树与双向链表

  - 这道题背就完事了
  - 这道题需要好好的看一遍题解去思考消化
- 面试题04.02、最小高度树（利用二叉搜索树性质，每次去数组中间的值作为节点的值）
- 669、修建二叉搜索树（利用二叉搜索树的性质，如果当前的值小于low，就把左子树砍掉，返回右子树；如果当前的值大于high，就把右子树砍掉，返回左子树）
- 99、恢复二叉树（也是利用二叉树搜索树和中序遍历的性质，但是其中利用r1和r2的方法真的很绝，建议好好看看）





### 平衡二叉树

- 110、平衡二叉树（自底向上的思考，如果当前的树不是，那上面的树也不是了，就往上走即可）





### 其他

- 116、填充每个节点的下一个右侧节点指针
  - 对于每个点，用solve（dfs函数）不断的递归
- 117、填充每个节点的下一个右侧节点指针II：依次遍历每一层，然后记录每个点的前一个点nodepre，让nodepre的next指向自己，然后再把自己变为nodepre
- 129、求根节点到叶节点数字之和（经典dfs）
- 112、路经总和（经典dfs）
- 226、翻转二叉树
- 113、路径总和II（经典dfs）
- 404、左叶子之和
  - 方法一：用flag来判断是不是左节点
  - 方法二：对于每个节点，都判断他的左节点，然后相加
- 538、把二叉搜索树转换为累加树
  - 这道题的思路很巧妙：用的是反向的中序遍历，先遍历右边，再处理root，最后遍历左边（其中还用了一个全局变量来维护右子节点的最大值）
  - 思路和实现上都比较简单，但是很难想到如此的巧妙
  - 而我的思路：对于一个节点本身来说，右子节点是用来给自身赋值的，所以，如果能往右边走，当前的值就是右边，就继续递归下去
  - 如果不能，那就继承父类给的base（具体参考代码）
  - 而对于左节点，如果左节点不能走，那以本节点为根节点的树的最大值就是root->val
  - 如果能走，那就返回递归的左节点
- 543、二叉树的直径
  - 遍历每个节点，每次的最大值都是左值加上右值（最大值用全局变量来维护）
- 863、二叉树中所有距离为 K 的结点
  - 真的巧妙啊，用哈希表实现dfs！！！！！
- 993、二叉树的堂兄弟节点
  - 比较层数和父母即可
- 字节面试题：二叉树中任意两节点之间的最短路径（给定两点，求它们之间的最短路径）
  - 思路：先找到两个点的最近公共祖先，然后再用dfs就该祖先到两点距离，最后相加
- nowcoder经典笔试题

  - 找到二叉树中的最大搜索二叉子树







### 个人思考

- 我发现啊，对于二叉树的题目，其实吧，如果用到深搜的话，就必然是递归加递归；如果是可以用广搜，那就是层序遍历，就是队列
