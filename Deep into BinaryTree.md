# 目录

- 235.二叉搜索树的最近祖先
- 236.二叉树的最近公共祖先
- 剑指 Offer 54. 二叉搜索树的第k大节点
- 538.把二叉搜索树转换为累加树
  - 这道题的思路很巧妙：用的是反向的中序遍历，先遍历右边，再处理root，最后遍历左边（其中还用了一个全局变量来维护右子节点的最大值）
  - 思路和实现上都比较简单，但是很难想到如此的巧妙
  - 而我的思路：对于一个节点本身来说，右子节点是用来给自身赋值的，所以，如果能往右边走，当前的值就是右边，就继续递归下去
  - 如果不能，那就继承父类给的base（具体参考代码）
  - 而对于左节点，如果左节点不能走，那以本节点为根节点的树的最大值就是root->val
  - 如果能走，那就返回递归的左节点

