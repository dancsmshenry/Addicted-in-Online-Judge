# 目录

- 235.二叉搜索树的最近祖先
- 236.二叉树的最近公共祖先
- 剑指 Offer 54. 二叉搜索树的第k大节点
- 538.把二叉搜索树转换为累加树
  - 这道题的思路很巧妙：用的是反向的中序遍历，先遍历右边，再处理root，最后遍历左边（其中还用了一个全局变量来维护右子节点的最大值）
  - 思路和实现上都比较简单，但是很难想到如此的巧妙
  - 而我的思路：对于一个节点本身来说，右子节点是用来给自身赋值的，所以，如果能往右边走，当前的值就是右边，就继续递归下去
  - 如果不能，那就继承父类给的base（具体参考代码）
  - 而对于左节点，如果左节点不能走，那以本节点为根节点的树的最大值就是root->val
  - 如果能走，那就返回递归的左节点
- 108.将有序数组转换为二叉搜索树
  - 经典传递数组和数组边界，然后递归
- 116.填充每个节点的下一个右侧节点指针
  - 对于每个点，用solve（dfs函数）不断的递归
- 404.左叶子之和
  - 方法一：用flag来判断是不是左节点
  - 方法二：对于每个节点，都判断他的左节点，然后相加
- 剑指offer33二叉搜索树的后序遍历
  - 经典传递数组边界

