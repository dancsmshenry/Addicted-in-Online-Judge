# 目录

- 235.二叉搜索树的最近祖先

- 236.二叉树的最近公共祖先

- 剑指 Offer 54. 二叉搜索树的第k大节点

- 538.把二叉搜索树转换为累加树
  - 这道题的思路很巧妙：用的是反向的中序遍历，先遍历右边，再处理root，最后遍历左边（其中还用了一个全局变量来维护右子节点的最大值）
  - 思路和实现上都比较简单，但是很难想到如此的巧妙
  - 而我的思路：对于一个节点本身来说，右子节点是用来给自身赋值的，所以，如果能往右边走，当前的值就是右边，就继续递归下去
  - 如果不能，那就继承父类给的base（具体参考代码）
  - 而对于左节点，如果左节点不能走，那以本节点为根节点的树的最大值就是root->val
  - 如果能走，那就返回递归的左节点
  
- 108.将有序数组转换为二叉搜索树
  - 经典传递数组和数组边界，然后递归
  
- 116.填充每个节点的下一个右侧节点指针
  - 对于每个点，用solve（dfs函数）不断的递归
  
- 404.左叶子之和
  - 方法一：用flag来判断是不是左节点
  - 方法二：对于每个节点，都判断他的左节点，然后相加
  
- 剑指offer33二叉搜索树的后序遍历
  - 经典传递数组边界

- 637.二叉树的层平均值：依次遍历每一层的，求平均值

- 515.在每个树行中找最大值：依次遍历每一层，然后maxn记录最大值

- 429.N叉树的层序遍历：依次遍历每一层，然后把值存下来

- 102.二叉树的层序遍历：如题，都不用操作....

- 117.填充每个节点的下一个右侧节点指针II：依次遍历每一层，然后记录每个点的前一个点nodepre，让nodepre的next指向自己，然后再把自己变为nodepre

- 222.完全二叉树的节点个数

  - ```cpp
    /*
    	思路：
            完全二叉树的一个性质是：所有的叶子节点都在最下面的那一层，同时节点是从左往右排列的
            所以就有了这样一个思路：
            （这段推理非常的精华，看完就理解二叉树递归的本质了，其实就是找到性质相同的子问题，然后用同一个函数不断的去求解）
            
            对于左子树和右子树来说，如果左子树和右子树的高度是相同的
            那就证明左子树的最后一层肯定是被叶子节点铺满的，但是右子树可能是没有被节点铺满的（也有可能被完全铺满）
                就将结果先加上左子树的结点数，然后再来看右子树的节点情况
            
            如果左子树的高度不等于右子树，那么必然是左子树最下面的叶子节点比右子树的叶子节点还要深入一层
            即在最后一行，左子树有节点，而右子树没有节点
                就将结果先加上右子树的结点数，然后再来看左子树的节点情况
        
    */
    ```

- 字节面试题：二叉树中任意两节点之间的最短路径（给定两点，求它们之间的最短路径）
  - 思路：先找到两个点的最近公共祖先，然后再用dfs就该祖先到两点距离，最后相加
  
- nowcoder经典笔试题

  - 找到二叉树中的最大搜索二叉子树







# 套路总结

- 对二叉树的题目的总结
  - 二叉树的遍历方式
    - 144，145，94，102
  - 二叉树的属性
    - 101，104，111，222，110，257，404，513，112
  - 二叉树的修改与构造
    - 226，106，654，617
  - 求二叉搜索树的属性
    - 700，98，530，501，538
  - 二叉树公共祖先问题
    - 236，235
  - 二叉搜索树的修改与构造
    - 701，450，669，108

- 我发现啊，对于二叉树的题目，其实把，如果用到深搜的话，就必然是递归加递归；如果是可以用广搜，那就是层序遍历，就是队列

- 层序遍历的套路题目
  - 思想：需要对树进行层序遍历，也可以认为是要进行广度优先搜索
  - 实操：建立一个queue（队列），最开始第一个root点放入队列，进行我们想要的操作（求最大值求平均值求最左边的数），注意此时一开始是用一个node1来接住这个点，然后把这个点给pop；操作完后，就把该点的左右结点给放入队列中，依次操作
