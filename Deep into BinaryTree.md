# 目录

- 剑指 Offer 54. 二叉搜索树的第k大节点

- 剑指offer33二叉搜索树的后序遍历

  - 经典传递数组边界

- 剑指offer 36 二叉搜索树与双向链表

  - 这道题背就完事了
  - 这道题需要好好的看一遍题解去思考消化

- 98.验证二叉搜索树

  - 

- 102.二叉树的层序遍历

  - 这道题有两种做法
  - 第一种：先设置全局变量res，里面是一个双层数组；用solve函数从根节点对树进行遍历，同时传递一个floor（表示当前结点的层数），每往下走一层就加一；然后开始遍历，如果当前数的层数大于等于数组的大小，就新插入一个数组进去，然后把当前的数放入，否则就直接放入数；注意，这里是先序遍历（根左右）的，就保证了是从左往右依次访问结点了
  - 第二种：在一般的套路中，层序遍历都是用队列来实现的

- 108.将有序数组转换为二叉搜索树

  - 经典传递数组和数组边界，然后递归

- 116.填充每个节点的下一个右侧节点指针

  - 对于每个点，用solve（dfs函数）不断的递归

- 117.填充每个节点的下一个右侧节点指针II：依次遍历每一层，然后记录每个点的前一个点nodepre，让nodepre的next指向自己，然后再把自己变为nodepre

- 124.二叉树的最大路径和（补，昨天听到他们在讨论这道题目，于是就review一下）

  - 对于一个二叉树的路径，对于一个点，无非就两种情况，第一种：从该点出发，只走左子树或右子树
  - 第二种：从左子树的某一处出发，经过该节点，然后到达右子树的某一处
  - 思路由此就出来了：设置全局变量maxn，设最开始的maxn为root -> val（如果nullptr就返回0）
  - 然后对该点进行遍历，走左边的最大值是多少，走右边的最大值是多少（注意，这里如果得到的是负数的话，就不应该走，就应该为0），然后，得到max1 = left + right + root -> val；
  - max1和maxn进行比较
  - 不过这个函数的精髓是，在探究走左子树的时候，就solve(root -> left)，右子树同理，即走左子树的时候，就考虑过了以左子树根节点为根节点的时候需要考虑的情况了
  - 同时最后返回的还是一个root -> val + max(left, right)，这里是max，是因为当别人调用你这个函数的时候，是以别人的结点为根节点出发的，所以你只能选择走左边或右边（也就是说，只有自己是根节点的时候，才能比较同时走左右两边的情况）

- 222.完全二叉树的节点个数

  - ```cpp
    /*
    	思路：
            完全二叉树的一个性质是：所有的叶子节点都在最下面的那一层，同时节点是从左往右排列的
            所以就有了这样一个思路：
            （这段推理非常的精华，看完就理解二叉树递归的本质了，其实就是找到性质相同的子问题，然后用同一个函数不断的去求解）
            
            对于左子树和右子树来说，如果左子树和右子树的高度是相同的
            那就证明左子树的最后一层肯定是被叶子节点铺满的，但是右子树可能是没有被节点铺满的（也有可能被完全铺满）
                就将结果先加上左子树的结点数，然后再来看右子树的节点情况
            
            如果左子树的高度不等于右子树，那么必然是左子树最下面的叶子节点比右子树的叶子节点还要深入一层
            即在最后一行，左子树有节点，而右子树没有节点
                就将结果先加上右子树的结点数，然后再来看左子树的节点情况
        
    */
    ```

- 235.二叉搜索树的最近祖先

- 236.二叉树的最近公共祖先

- 404.左叶子之和

  - 方法一：用flag来判断是不是左节点
  - 方法二：对于每个节点，都判断他的左节点，然后相加

- 429.N叉树的层序遍历：依次遍历每一层，然后把值存下来

- 515.在每个树行中找最大值：依次遍历每一层，然后maxn记录最大值

- 538.把二叉搜索树转换为累加树
  - 这道题的思路很巧妙：用的是反向的中序遍历，先遍历右边，再处理root，最后遍历左边（其中还用了一个全局变量来维护右子节点的最大值）
  - 思路和实现上都比较简单，但是很难想到如此的巧妙
  - 而我的思路：对于一个节点本身来说，右子节点是用来给自身赋值的，所以，如果能往右边走，当前的值就是右边，就继续递归下去
  - 如果不能，那就继承父类给的base（具体参考代码）
  - 而对于左节点，如果左节点不能走，那以本节点为根节点的树的最大值就是root->val
  - 如果能走，那就返回递归的左节点
  
- 637.二叉树的层平均值：依次遍历每一层的，求平均值

- 字节面试题：二叉树中任意两节点之间的最短路径（给定两点，求它们之间的最短路径）
  - 思路：先找到两个点的最近公共祖先，然后再用dfs就该祖先到两点距离，最后相加
  
- nowcoder经典笔试题

  - 找到二叉树中的最大搜索二叉子树







# 套路总结

- 对二叉树的题目的总结
  - 二叉树的遍历方式
    - 144，145，94，102
  - 二叉树的属性
    - 101，104，111，222，110，257，404，513，112
  - 二叉树的修改与构造
    - 226，106，654，617
  - 求二叉搜索树的属性
    - 700，98，530，501，538
  - 二叉树公共祖先问题
    - 236，235
  - 二叉搜索树的修改与构造
    - 701，450，669，108
- 我发现啊，对于二叉树的题目，其实把，如果用到深搜的话，就必然是递归加递归；如果是可以用广搜，那就是层序遍历，就是队列
- 对于二叉树，一类题的骨架就是，前中后序遍历，带着这个思路去思考问题（剑指offer36，这道题非常的经典，需要好好的思考一下）
- 层序遍历的套路题目
  - 思想：需要对树进行层序遍历，也可以认为是要进行广度优先搜索
  - 实操：建立一个queue（队列），最开始第一个root点放入队列，进行我们想要的操作（求最大值求平均值求最左边的数），注意此时一开始是用一个node1来接住这个点，然后把这个点给pop；操作完后，就把该点的左右结点给放入队列中，依次操作

- 挖坑：实现非递归版本的前中后序遍历？？感觉这个挺常见的
