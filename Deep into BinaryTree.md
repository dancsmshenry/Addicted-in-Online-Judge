# 目录

- 剑指offer 54. 二叉搜索树的第k大节点

- 剑指offer 33.二叉搜索树的后序遍历

  - 经典传递数组边界

- 剑指offer 36.二叉搜索树与双向链表

  - 这道题背就完事了
  - 这道题需要好好的看一遍题解去思考消化

- 98、验证二叉搜索树

- 102、二叉树的层序遍历

- 103、二叉树的锯齿形层序遍历

- 108.将有序数组转换为二叉搜索树

  - 经典传递数组和数组边界，然后递归

- 116.填充每个节点的下一个右侧节点指针

  - 对于每个点，用solve（dfs函数）不断的递归

- 117.填充每个节点的下一个右侧节点指针II：依次遍历每一层，然后记录每个点的前一个点nodepre，让nodepre的next指向自己，然后再把自己变为nodepre

- 124.二叉树的最大路径和（补，昨天听到他们在讨论这道题目，于是就review一下）

  - 对于一个二叉树的路径，对于一个点，无非就两种情况，第一种：从该点出发，只走左子树或右子树
  - 第二种：从左子树的某一处出发，经过该节点，然后到达右子树的某一处
  - 思路由此就出来了：设置全局变量maxn，设最开始的maxn为root -> val（如果nullptr就返回0）
  - 然后对该点进行遍历，走左边的最大值是多少，走右边的最大值是多少（注意，这里如果得到的是负数的话，就不应该走，就应该为0），然后，得到max1 = left + right + root -> val；
  - max1和maxn进行比较
  - 不过这个函数的精髓是，在探究走左子树的时候，就solve(root -> left)，右子树同理，即走左子树的时候，就考虑过了以左子树根节点为根节点的时候需要考虑的情况了
  - 同时最后返回的还是一个root -> val + max(left, right)，这里是max，是因为当别人调用你这个函数的时候，是以别人的结点为根节点出发的，所以你只能选择走左边或右边（也就是说，只有自己是根节点的时候，才能比较同时走左右两边的情况）

- 144、二叉树的前序遍历

- 145、二叉树的后序遍历

- 199、二叉树的右视图

- 222.完全二叉树的节点个数

  - 完全二叉树的一个性质是：所有的叶子节点都在最下面的那一层，同时节点是从左往右排列的
  - 所以就有了这样一个思路：
    - 这段推理非常的精华，看完就理解二叉树递归的本质了，其实就是找到性质相同的子问题，然后用同一个函数不断的去求解
    - 对于左子树和右子树来说，如果左子树和右子树的高度是相同的，那就证明左子树的最后一层肯定是被叶子节点铺满的，但是右子树可能是没有被节点铺满的（也有可能被完全铺满），就将结果先加上左子树的结点数，然后再来看右子树的节点情况
    - 如果左子树的高度不等于右子树，那么必然是左子树最下面的叶子节点比右子树的叶子节点还要深入一层，即在最后一行，左子树有节点，而右子树没有节点，就将结果先加上右子树的结点数，然后再来看左子树的节点情况
  
- 235.二叉搜索树的最近祖先

- 236.二叉树的最近公共祖先

- 404.左叶子之和

  - 方法一：用flag来判断是不是左节点
  - 方法二：对于每个节点，都判断他的左节点，然后相加

- 429.N叉树的层序遍历

- 515.在每个树行中找最大值

- 538.把二叉搜索树转换为累加树
  - 这道题的思路很巧妙：用的是反向的中序遍历，先遍历右边，再处理root，最后遍历左边（其中还用了一个全局变量来维护右子节点的最大值）
  - 思路和实现上都比较简单，但是很难想到如此的巧妙
  - 而我的思路：对于一个节点本身来说，右子节点是用来给自身赋值的，所以，如果能往右边走，当前的值就是右边，就继续递归下去
  - 如果不能，那就继承父类给的base（具体参考代码）
  - 而对于左节点，如果左节点不能走，那以本节点为根节点的树的最大值就是root->val
  - 如果能走，那就返回递归的左节点
  
- 637.二叉树的层平均值

- 字节面试题：二叉树中任意两节点之间的最短路径（给定两点，求它们之间的最短路径）
  - 思路：先找到两个点的最近公共祖先，然后再用dfs就该祖先到两点距离，最后相加
  
- nowcoder经典笔试题

  - 找到二叉树中的最大搜索二叉子树



# 总结

- 对二叉树的题目的总结
  - 二叉树的属性
    - 101，104，111，222，110，257，404，513，112
  - 二叉树的修改与构造
    - 226，106，654，617
  - 求二叉搜索树的属性
    - 700，98，530，501，538
  - 二叉树公共祖先问题
    - 236，235
  - 二叉搜索树的修改与构造
    - 701，450，669，108



### 二叉树的基本性质

- 思路：二叉搜索树的基本性质，二叉树前中后序遍历的特性
- 例题：
  - 105、从前序与中序遍历序列构造二叉树



### 层序遍历

- 思想：需要对树进行层序遍历，也可以认为是要进行广度优先搜索
- 实操：建立一个queue（队列），最开始第一个root点放入队列，进行我们想要的操作（求最大值求平均值求最左边的数），注意此时一开始是用一个node1来接住这个点，然后把这个点给pop；操作完后，就把该点的左右结点给放入队列中，依次操作（踩坑：注意，for循环的是一开始队列的大小size，否则的话，后续的元素不断放入，size会改变的）
- 例题：
  - 102、二叉树的层序遍历（基本模板，代码有我最开始的一种简陋的做法）
  - 515、在每个树行中找最大值（层序遍历每层，记录max）
  - 429、N叉树的层序遍历（层序遍历每层）
  - 637、二叉树的层平均值（依次遍历每一层的，求平均值）
  - 199、二叉树的右视图（层序遍历，每次只取最后一个数）
  - 103、二叉树的锯齿形层序遍历（层序遍历，控制深度反转数组）
  - 面试题 04.03. 特定深度节点链表（层序遍历生成链表）



### 前中后序遍历

- 思想：就是二叉树最基本的前中后遍历，不过一般会添加一些操作在上面
- 实操：遍历一般有两种方式来实现，第一种是递归，第二种是用栈模拟递归（挖坑：第三种遍历mirror不会，后续填坑）
- 例题：
  - 144、二叉树的前序遍历（递归非递归版）
  - 145、二叉树的后序遍历（递归非递归版）
  - 98、验证二叉搜索树（这道题是用到了二叉搜索树的性质+中序遍历。即对于每棵树，根节点是大于左子树的节点的，右子树的节点是大于根节点的；然后联想到中序遍历是左根右的，所以就一方面维护一个pre节点，另一方面左根右的遍历，走完左子树，pre就变为左子树中的最大值（即左子树的右子树其中一个值），和根节点比较；走完根节点，pre就变为根节点，和右子树的左子树的最小值（即右子树的左子树其中一个值）进行比较）；这就是中序遍历的高深之处，始终维护着pre为一部分的最大值
  - 590、N叉树的后序遍历（换汤不换药啊）
  - 剑指offer36（这道题非常的经典，需要好好的思考一下）



### 个人思考

- 我发现啊，对于二叉树的题目，其实吧，如果用到深搜的话，就必然是递归加递归；如果是可以用广搜，那就是层序遍历，就是队列
