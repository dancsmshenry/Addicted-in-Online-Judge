# 目录

### 思考

- 二分查找为什么不用四六分或三七分？
- 具体分析各个边界去不同的小于大于等于号的不同情况
- 如何面对浮点数的查找
- 二分查找的本质是什么（参考旋转数组，应该是两边的数组都具有一个相同的特性）
- 如果数组有重复，该怎么办？





### 二分模板

- ```cpp
  //要求，找当前target在nums中的位置，如果在，就返回下标；否则，返回它应该插入的位置
  int left = 0, right = nums.size() - 1;
  
  //二分模板1.0（缺点，如果存在数字大于当前最大的数字的话，返回的只能是数组的长度，而不是该元素应该插入的位置；但如果是小于最大的数，但是又不在里面的话，就可以返回该元素应该插入的位置）
  while (left < right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] < target) {
          left = mid + 1;
      } else {
          right = mid;
      }
  }
  return right;
  
  //二分模板1.1，和1.0一样，不过需要调整的是mid这里要加一，因为如果left=right-1，那么left=mid的时候，就会无限循环，走不出去了（和1.0一样的缺点）
  while (left < right) {
      int mid = left + (right - left + 1) / 2;
      if (nums[mid] <= target) {
          left = mid;
      } else {
          right = mid - 1;
      }
  }
  return right;
  
  /**
   * 对于1.0的版本，可以找到该元素在数组里面出现的第一个位置(因为如果nums[mid]==target的时候，我们查询的是左边的区间，这样不断地找，就可以找到第一次出现的位置)
   * 1.1的版本，可以找到出现的最后一个位置(因为如果nums[mid]==target的时候，我们选择的是查询右边的区间，这样不断地找，就可以找到它出现地最后一次地位置)
   * **/
  
  //二分模板2.0（克服了1.0的缺点）
  while (left <= right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] >= target) {
          right = mid - 1;
      } else {
          left = mid + 1;
      }
  }
  return left;
  
  //二分模板3.0，最简单易懂的模板，也是克服了1.0的缺点，但是比2.0更加容易理解
  while (left <= right) {
      int mid = left + (right - left) / 2;
      if (nums[mid] == target) {
          return mid;
      } else if (nums[mid] > target) {
          right = mid - 1;
      } else {
          left = mid + 1;
      }
  }
  return right + 1;
  
  //参考：
  // https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/
  // https://zhuanlan.zhihu.com/p/79553968
  // 二分查找（有重复）（如何操作？）
  ```





### 旋转数组

- 旋转数组中找最小数字，存在重复元素
  - 154. 寻找旋转排序数组中的最小值 II
  - 剑指 Offer 11. 旋转数组的最小数字
  - 思路：
    - 找到规律使用二分查找
    
    - 如果mid和right相等的话应该怎么办（right--）
    
    - 防止长度溢出
    
    - 为什么不能用left进行比较
    
    - ```cpp
              /*
              本题的思路：
              看到数组类型的题目，想到的就是双指针和二分查找
              很明显，对于旋转后的数组有两种情况，一种是前面的较大的那一部分数组长度大于数组长度的一半
              另一种情况是前面的较大的那一部分数组长度小于数组长度的一半
              那这个时候就要找规律了
              你看，如果中间的那个数大于左边（或者中间的那个数大于右边），那最小的数就在右边，对于第一种情况
              否则，中间的数小于左边（或者中间的那个数小于右边），那最小的数就在左边，对应第二种情况
            
              那现在有两种情况都可以用，是不是都可行呢？
              那，其实比较左边数的方法是不可行的
              因为如果到某一个时候，分隔到的小数组是没有被旋转的
              那我中间的数大于左边的数，然后就直接往右边寻找了
              很显然是错误的
              所以只能是对右边的数进行比较
            
              debug：这道题比较坑的地方是，他会出现元素相等的情况
              想到了早上在评论区看到的一个解答：
              如果遇到当前的mid值和边界值相等，怎么办？就把边界值向中间靠拢一个单位
              我的理解：既然当前的mid对应的值和边界值相等，那我就把边界靠拢向中间，然后再来一次二分
              相等就继续二分，直到不相等，这样就在缩小范围的同时，也能有效避免因为相同元素导致递归结果错误
              因为如果二者相等的话，其实我们是不知道到底因该想做还是向右的（即第一种情况或者第二种情况都会发生）
            
              就相当于二分的魔改了
              */
      ```
    
    - 一点理解
- 旋转数组中找最小元素，不存在重复元素
  - 153. 寻找旋转排序数组中的最小值
  - 思路：
    - 没啥好说的，二分硬怼完事
    - 防止长度溢出
    - 为什么不能用left进行比较
- 搜索旋转数组，不存在重复元素（返回下标）
  - 33. 搜索旋转排序数组
  - 思路：
    - 二分，但每次使用二分的时候判断当前查找的数组是什么情况（是前半段的长度大于一半，还是小于一半的）
    - 防溢出
    - 思考：left <= right时=的用处，以及这里为什么nums[mid] >= nums[left]
- 搜索旋转数组，存在重复元素（返回是否存在）
  - 81. 搜索旋转排序数组 II
  - 思路：
    - 思路和上面一样
    - 细节就是，如果发现mid和left相同的话，应该如何处理（left++）
- 搜索旋转数组，存在重复元素（返回目标元素第一次出现的位置的下标）
  - 面试题 10.03. 搜索旋转数组
  - 思路：
    - 这道题和上面略有不同的是，如果当前的mid等于target，不是直接返回结果，而是缩小right的范围
    - 同时，如果left等于target的话，就返回left
- 注意：因为是搜索元素，所以不一定会存在的，while那里要判断left和right相等的情况





### 二分搜索

- 35、搜索插入位置（二分，需要注意的就是如果当前没有要查找的数应怎么办）
- 34、在排序数组中查找元素的第一个和最后一个位置（两次二分）
- 633、平方数之和（二分，有点巧妙，需要多看看）
- 69、x的平方根（二分，同上）
- 162、寻找峰值（二分，如果后面的比我大，那就证明后面必定有山峰，否则就山峰就在前面）
- 剑指 Offer 53 - I. 在排序数组中查找数字 I（二分得到数字，然后++求和）
- 二维数组寻找峰值（和一维的类似：先找一列上的峰值，然后看是否为左右峰值，不是的话再继续调整）
- 剑指 Offer II 069. 山峰数组的顶部
  - 一开始写这道题的时候出现了死循环，后面发现，是因为每次得到mid的时候，都是和前面的数字进行比较，就会导致如果后面只剩下两个数字的时候，得到的mid始终是left，mid如果大于前面的，left还即使更新了还是不变，就会造成死循环（注意，如果只剩两个数字，得到mid必然是大于前面一个数字的，比如5，8，9中，无论是5和8，还是8和9，都是一样的）
  - 解决办法就是每次比较后面一个属性
  - 这里给我们的一个启发就是，要假设最后只有两个数字，那此时会不会死循环






### 双调数组

- 双调数组04（对一个先递增后递减的数组去重，要求时间复杂度O(n)）
  - 从左右两个指针开始向中间走，谁小就谁放进去，放完后再去重





### Others

- 4.寻找两个正序数组的中位数

  - 记录一个老哥的题解，分析的非常到位

  - ```cpp
    /**
    解题思路：二分法
    
    此题求两个有序数组的中位数，并且限制时间复杂度为O(log (m+n))，所以自然想到要用二分法求解。
    
    中位数：如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为m和n，由于两个数组长度之和m+n的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。
    
    使用一个小trick，可以避免讨论奇偶：
    我们分别找第 (m+n+1)/2个数，和(m+n+2)/2个数，然后求其平均值即可，这对奇偶数均适用。假如 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。
    
    那么接下来重点就变成如何在两个有序数组中找到第K个（第k小的）元素。
    首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量 i 和 j 分别来标记数组nums1和nums2的起始位置。
    
    递归出口：
    当K=1时候，相当于求最小值，我们只要比较nums1和nums2的起始位置i和j上的数字就可以了。
    
    一般情况：
    取两个数组中的第k/2个元素（midVal1和midVal2）进行比较，如果midVal1 < midVal2，则说明数组1中的前k/2个元素不可能成为第k个元素的候选，所以将数组1中的前k/2个元素去掉，作为新数组和数组2求第k-k/2小的元素，因为我们把前k/2个元素去掉了，所以相应的k值也应该减少k/2。midVal1 > midVal2的情况亦然。
    
    边界问题：
    
    当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。
    
    由于两个数组的长度不定，所以有可能某个数组元素数不足k/2，所以我们需要先检查一下，数组中到底存不存在第K/2个数字，如果存在就取出来，否则就赋值上一个整型最大值，这样肯定会大于另一个数组的第k/2个元素，从而把另一个数组的前k/2个元素淘汰。
    
    ps：赋予整型最大值的意思只是说如果第一个数组的K/2不存在，则说明这个数组的长度小于K/2，那么另外一个数组的前K/2个我们是肯定不要的。例如，加入第一个数组长度是2，第二个数组长度是12，则K为7，K/2为3，因为第一个数组长度小于3，则无法判断中位数是否在其中，而第二个数组的前3个肯定不是中位数！
    
    每一轮次的快排都需要选择一个枢轴 pivot，上面的解法里默认以 low 下标指向的数组元素作为枢轴，也就是每次排序都以最左边的第一个元素作为枢轴，这时候比较的顺序就必须先从右往左比较再从左往右比较，如此才能保证每一轮次的快排都能让比枢轴小的元素被换到了枢轴左边，比枢轴大的元素被换到了枢轴右边。
    
    反之，如果先从左往右比较再从右往左比较(就是你说的两行互换后的写法)，在两次 while 结束后 i 和 j 碰面的位置对应的数组元素必定大于枢轴，之后 swap 的时候就会把大元素与枢轴进行 swap，这样就无法保证枢轴两侧左小右大的结果了
    **/
    ```

- 有序矩阵中第k小的元素
