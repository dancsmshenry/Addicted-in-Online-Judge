class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        /**
        好久没有写题目了，感觉手都生疏了..
        看到这道题，我有好多的奇奇怪怪的想法，就是有些思绪上的错误，导致一直做不出来
        我的方法：
        其实就找一下第一个不在自己为止的数字，把他应该在的位置作为left
        再找一下最后一个不在自己位置的数字，把他应该在的位置作为right，搞定
        虽然看起来很容易，但是做起来真的很不好实现，直到后面我看了解析好久才明白
        标准答案：
        一个基本思路：最小的数的所有数都要排序，最大的数的所有数都要排序
        那我找到了比较大的那个数，然后往右边找，如果比这个数小，那么就把这个数作为right
        但如果比这个数大，就更新这个数（欸，这里是不用更新right的，因为如果后面还有比这个小的，才会更新；否则的话这里可能就是最后一个数了）
        （同时，如果一直都比这个数大下去的话，就证明这一段是有序的）

        那么最小的部分（即left怎么操作呢？）同样的
        从右往左来找，也是记录最小的，如果比最小的还小，就记录下来
        否则的话就更新为left
        **/
        int maxn = INT_MIN, minn = INT_MAX;
        int left = 0, right = 0, n = nums.size();

        for (int i = 0; i < n; i ++ ){
            if (nums[i] >= maxn){
                maxn = nums[i];
            }else{
                right = i;
            }

            if (nums[n - 1 - i] <= minn){
                minn = nums[n - 1 - i];
            }else{
                left = n - 1 - i;
            }
        }

        if (right == left){
            return 0;
        } else{
            return right - left + 1;
        }

        /**
        思考与反思：
        我最开始的一个方法，就是判断最大值和最小值是不是在原位上，如果不是的话，就allin就行了（可是如果是在原位上的话，那就不好处理了，这是这种方法的缺点）
        然后看了解析给的方法就是：我从左往右一定是越来越大的，如果你比我当前最大的还大，我就维护你，否则的话，你这个位置肯定是要进行排序的，所以就用right来记录下来
        然后再往后遍历，如果仍旧是越来越大的话，就只是维护（越来越大，就肯定是有序的嘛）；可如果出现了比前面数列还小的，就需要去修改right了
        这种维护最大值的方式就很好的解决了以下情景：如果最大值就在最后一位，那该如何处理
        好巧妙的双指针啊！
        **/
    }
};