class Solution {
public:
    int cuttingRope(int n) {
        /*如果传入的数字是2，3的话，那么得到的结果刚好就是1，2*/
        if (n <= 3){
            return n - 1;
        }

        /*
        先预先记录一个b，用于后续的判断
        这里的一个设计思路就是：通过数学的推理，可以得到把数字拆为3是可以一直获得最大值
        而如果一直乘以3的话会很慢，所以又用了快速幂来解决这个问题
        这里res用于存储答案，x作为快速幂的基数

        这里的x可能会超过int的大小，所以要用long来扩容
        */
        long x = 3, b = n % 3, res = 1, mod = 1000000007;
        /*
        这里i还要减一，是因为后续要用来和b结合来检查是否能够获得更大值
        快速幂的思路：
        对于10^5来说，可以认为是100^2*10，所以如果当前的系数mod2后得到1，就预先把他乘进去，再增大基数
        而如果mod2后为0的话，就只要增大基数就好了
        同时不用担心后续会乘不到数据，因为最后会出现1%2的情况，这样就会把前面所有的基数全部乘起来（例：10^16）
        */
        for (int i = n / 3 - 1; i > 0; i /= 2){
            if (i % 2 == 1){
                res = (res * x) % mod;
            }
            x = (x * x) % mod;
        }

        /*
        通过上面记录得到的b的值，和最后余留下来一个3，可以得到4，3，6等三种情况
        如果b为1，则结合得到4，能取得的最大值就是4
        如果b为0，则结合得到3，能取得的最大值就是3
        如果b为2，则结合得到5，能取得的最大值就是6
        */
        if (b == 1){
            return (res * 4) % mod;
        }else if (b == 0){
            return (res * 3) % mod;
        }

        return (res * 6) % mod;
    }
};