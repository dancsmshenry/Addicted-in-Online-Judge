class Solution {
public:
    int numTrees(int n) {
        /*
        设新来的点比当前所有的点都大
        放法一：把之前的二叉树作为该点的左子树（f[n - 1]）
        放法二：对于之前的二叉树，计算每棵树又多少个右子树，就在该右子树的位置放上这个最大值点，并把原来的右子树作为它的左子树（??）

        看了解析后思路豁然开朗：
        对于每一棵二叉搜索树来说，可以先假设它的数字是1到n
        对于每一个点来说，都可以作为树的根节点，设这个数为n1，它的左边是1到n1 - 1，它的右边是n1 + 1到n
        那么对于以n1为根节点的树，它的情况就有f[1...n1-1]*f[n1+1...n]这么多的情况
        所以依次循环遍历每个点即可
        */
        int f[n + 1];
        memset(f, 0, 4*(n + 1));//小坑，这里是要以字节为单位去格式化的，不是按照int的数量来格式化的
        f[0] = 1;
        f[1] = 1;

        for (int i = 2; i <= n; i ++ ){
            for (int j = 1; j <= i; j ++ ){
                f[i] += (f[i - j] * f[j - 1]);
            }
        }

        return f[n];
    }
};