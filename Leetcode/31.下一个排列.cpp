class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        /**
        问题：
        什么是字典序：
        在数学中，字典或词典顺序（也称为词汇顺序，字典顺序，字母顺序或词典顺序）是基于字母顺序排列的单词按字母顺序排列的方法
        这种泛化主要在于定义有序完全有序集合（通常称为字母表）的元素的序列（通常称为计算机科学中的单词）的总顺序

        题目的意思是什么：
        当前的排序状况肯定是在字典序里面的，那么现在要找的就是下一个比当前排序大的排序（按照字典序的顺序找）

        对字典序的一个理解：就从后往前数，一定有一部分是有序的
        而字典序的基本操作就是，每次都从这部分有序的数组中，拿一个数放到前面

        所以，下一个排序一定比当前的排序要大（除了最后一个）

        续：
        思路：在字典序中找到下一个排序，其实就是想找的下一个比它大，但是又没那么大的数字
        即刚好比它大一点的那个数字（这里的前提是要理解字典序是如何排序的）
        那如何找这个数字呢？
        题解给的办法就是，找一个坐标j，使得j到end数组是降序的，而j-1对应的数字小于j对应的数字

        很明显，对于这个降序的数组，怎么排序都排不到一个比它还大的数字，所以要借助j-1对应的数字
        
        也就是说j-1对应的数字要假如到排序当中，那，j-1的位置应该是一个怎样的数字呢？
        如果比j-1小，那整体就比现在的数字还要小了
        如果说等于j-1，那不就相当于没有发生变化吗
        所以，必须比j-1要大才行
        那，ok，我们就确定了，j-1的位置必须是一个刚好比j-1大的数字
        同时，因为j到end是降序的，所以从后往前找第一个比j-1大的数，就是刚好比j-1大的数
        所以就交换两个数字的位置
        于是就把这个数作为这一段的头头

        那接下来的问题是，如何排列后面的数据呢？
        这里的一个小前提是，因为是交换的，所以后面的数据，从j到end，就都还是降序的
        那就变成了，下一个排列的最前面的头头换了，后面的数据如何排序？
        答，从左往右，升序即可（而从j到end又都是降序的，所以就之间反转就好了）
        **/

        int i = nums.size() - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]){
            i -- ;
        }

        if (i >= 0){
            int j = nums.size() - 1;
            while (j >= 0 && nums[i] >= nums[j]){
                j -- ;
            }
            swap(nums[i], nums[j]);
        }
        
        reverse(nums.begin() + i + 1, nums.end());//reverse是第一个参数的位置，直到最后一个参数之前的位置的
    }
};