# 目录

## 基本知识

### QuickSort

- 快速排序的实现

  - 递归版本

  - ```cpp
    /*arr为需要排序的数组，left为左边界，right为右边界*/
    void quick_sort(vector<int> &arr, int left, int right)
    {	
        /*当前只有一个数（或边界left>right）的时候，就不用排序了*/
    	if (left >= right) return;
    	
        /*选取最左边的那一个数作为排序的标准，i从左边开始，j从右边开始*/
    	int temp = arr[left], i = left - 1, j = right + 1;
    	while (i < j)
    	{	
            /*从左边开始，寻找大于等于temp的数*/
    		do i ++ ; while (arr[i] < temp);
            /*从右边开始，寻找小于等于temp的数*/
    		do j -- ; while (arr[j] > temp);
            /*交换数字*/
    		if (i < j) swap(arr[i], arr[j]);
    	}
    	
        /*对左边的部分进行快排*/
    	quick_sort(arr, left, j);
        /*对右边的部分进行快排*/
    	quick_sort(arr, j + 1, right);
    }
    
    /**
    	Q：i<j可不可以换为i<=j
    	A：可以，当i=j的时候，交换自身不会影响结果
    	
    	Q：arr[i]<temp可不可以换为arr[i]<=temp（或者arr[j]>temp可不可以换为arr[j]>=temp）
    	A：不可以，对于一些数据，会因此陷入无限循环（例：9，8，7，6，5，4，3，2，1）
    	原因分析：因为可能后面所有的数都会小于此时的temp，那么i就会一直往后面递增（对于j也是同理）
    	
    	Q：quick_sort(arr, left, j)，quick_sort()可否改为quick_sort(arr, left, i)
    	A：不可以，因为我们是temp=arr[left]的，结合第二个问题提供的例子（9，8，7，6，5，4，3，2，1），即i是有可能会出界的
    	或者也有可能是（1，2，3，4，5，6），到最后i为0，i-1还是会越界
    	而以j为界则不会出现这样的情况，首先，面对例子（1，2，3，4，5，6），j最后会指向0的位置，j+1就不会越界
    	又因为第一次循环的时候，arr[i]=temp，就一定会和arr[j]进行一次交换，导致j在第二次遍历的时候最多指向arr[j-1]，
    	即最多指向arr[n - 2]，那么此时的j+1也不会越界
    **/
    ```

  - 非递归版本

  - ```cpp
    /*arr为需要排序的数组*/
    void quick_sort(vector<int> &arr)
    {
        /*栈用于记录需要排序的区间，存储的分别是left和right两个端点的下标*/
        stack<array<int, 2>> s;
        /*先初始化栈，放入数组的头尾下标*/
        s.push((array<int, 2>){0, arr.size() - 1});
        /*如果栈不为空，就代表还有没排序好的数据*/
        while (!s.empty())
        {	
            /*获取栈顶的数据区间*/
            array<int, 2> a{s.top()};
            /*下列会对该区间排序，所以就把其弹出*/
            s.pop();
            /*左边界小于右边界*/
            if (a[0] < a[1]){
                /*基本的快排*/
                int temp = arr[a[0]], i = a[0] - 1, j = a[1] + 1;
                while (i < j)
                {
                    do i ++ ; while (arr[i] < temp);
                    do j -- ; while (arr[j] > temp);
                    if (i < j) swap(arr[i], arr[j]);
                }
                /*将区间再分为两个区间，然后再排序*/
                s.push({a[0], j});
                s.push({j + 1, a[1]});
            }
        }
    }
    ```

- 分析是否为稳定排序、时间复杂度的推导、时间和空间复杂度
  - 不是稳定排序（可以参考每次选出的哨兵temp，一开始都是在左边，交换后都到了右边）
  - 时间复杂度：最好和平均都是O（nlogn），最坏的时候要到O（n^2）
  - 空间复杂度：O（1）
- 快速排序的优化

  - 在选择哨兵的时候使用三数取中法，即取序列第一个元素、中间元素以及最后一个元素，在取这三个元素的中位数作为哨兵，可以避免取到边缘值而导致每次分割不均匀的情况
  - 因为在递归分割序列时，序列的长度会越来越短，又因为短序列排序中插入排序效率最高，所以可以设置一个阈值，当序列长度分割到阈值时切换到插入排序，提高效率
  - 当序列中存在大量相同元素，或者全是相同元素时，使用快排仍然会得到最低效率，这时可以采用聚集相等元素的方法，每次选择哨兵后，将与哨兵相同的元素放到序列中间，下次分割时中间这些值不参与分割
  - 当递归层数过深的时候改用堆排序，虽然第一个优化方法避免了取到边缘哨兵，但还是有可能取到较边缘的哨兵，最坏的情况会导致递归层数过深，从而降低快排效率，所以每次递归要判断递归层数，达到一定深度就改用堆排序，这是stl源码里实现的方法。之所以要用堆排序，我猜想可能是因为快排和归并都是基于递归的排序，此时递归深度已经太深，肯定不能再用了，而对于较长的序列使用插入排序效率也不是太高，所以选择了堆排序





### BubbleSort

- 冒泡排序的实现

  - ```cpp
    /*arr为需要排序的数组*/
    void bubble_sort(vector<int> &arr)
    {
        /*check为哨兵，如果没有出现数据交换，证明数据都是有序的，退出循环*/
    	bool check = false;
        /*寻找第一大，第二大，第三大..的数据*/
    	for (int i = arr.size() - 1; i > 0; i --)
    	{
            /*挨个挨个的比较数据*/
    		for (int j = 0; j < i; j ++)
    		{
    			if (arr[j] > arr[j + 1])
    			{
    				swap(arr[j], arr[j + 1]);
    				check = true;
    			}
    		}
            /*没有发生数据交换，退出循环*/
    		if (!check) break;
    	}
    }
    ```

- 分析是否为稳定排序、时间复杂度的推导、时间和空间复杂度
  - 是稳定排序（如果是`arr[j] >= arr[j + 1]`就不是稳定排序了）
  - 时间复杂度：最好是O（n）（没有哨兵的优化就是O（n ^ 2）），最坏是O（n ^ 2），平均是O（n ^ 2）
  - 空间复杂度：O（1）
- 冒泡排序的优化
  - 每一次二级循环都放置一个哨兵，如果flag不变，则说明有序，就不要继续排序了





### MergeSort

- 归并排序的实现

  - ```cpp
    void merge_sort(vector<int>& arr, int left, int right)
    {
        /*如果右边边界小于等于左边边界，退出排序*/
    	if (left >= right) return;
    
    	int mid = (left + right) >> 1;
        /*对左边数据排序*/
    	merge_sort(arr, left, mid);
        /*对右边数据排序*/
    	merge_sort(arr, mid + 1, right);
    	
        /*这里假设数据左右数据都排好序了，进行归并操作*/
    	int k = 0, i = left, j = mid + 1;
        /*
        	temp用来存储中途的数据，这里原代码是作为一个全局变量
        	i从左边开始，j从中间开始
        	分别将数据按大小放入temp中
        */
    	while (i <= mid && j <= right){
            /*哪一边的比较小，就放入哪一边的数*/
    		if (arr[i] <= arr[j]) tmp[k ++ ] = arr[i ++ ];
    		else tmp[k ++ ] = arr[j ++ ];
    	}
        /*
        	可能左边或右边的数没有全部放完，于是用while把数据全部放进去
        	ps：左边和右边只可能有一边的数据没有完全放完
        */
    	while (i <= mid) tmp[k ++ ] = arr[i ++ ];
    	while (j <= right) tmp[k ++ ] = arr[j ++ ];
    	
        /*把排好序的数据放回arr中*/
    	for (i = left, j = 0; i <= right; i ++, j ++) arr[i] = tmp[j];
    }
    ```

- 分析是否为稳定排序、时间复杂度的推导、时间和空间复杂度

  - 可能是稳定排序，也可能不是，这和数据有关
  - 时间复杂度





### HeapSort

- 堆排序的实现

  - ```cpp
    /*
    	对于每个结点，堆的构建过程
    	
    	前置知识：（注意，这里都是从0开始计数的）
    	对于一个结点，如何找到它的叶子结点呢？
    	对于完全二叉树来说，它的左叶子结点是2 * i + 1，右叶子结点是2 * i + 2
    	（小证：对于一层中的最左边的结点i，他到最右边的结点之间是差了i的，参考2的n+1次方和2的n次方的关系，这里的i就相当于2的n次方，
    	最后一个节点就相当于2的n+1次方）
    	
    	回过头来，对于父母结点，两个叶子结点，谁做父母结点呢？
    	大的那个吗？
    	对，又因为，但是如果大的那个是叶子结点，那对于叶子结点的那个堆树，就又破坏了它的性质了
    	所以如果是叶子结点作为当前的结点的话，就要对叶子结点的那棵树进行重新构造
    */
    void HeapAdjust(int a[], int x, int n)
    {
        int l = x * 2 + 1, r = x * 2 + 2;
        int max = x;
    
        if (l < n && a[l] > a[max]) max = l;
        if (r < n && a[r] > a[max]) max = r;
    
        if (max != x){
            swap(a[x], a[max]);
            HeapAdjust(a, max, n);
        }
    }
    
    /*
    	前置知识：（注意，这里都是从0开始计数的）
    	堆：是具有以下性质的完全二叉树，每个结点的值都大于或等于其左右孩子结点的值，称为大根堆；
    	或者每个结点的值都小于或等于其左右孩子结点的值，称为小根堆
    	
    	一个问题，对于一个完全二叉树，我们如何找到它的最后一个父母结点？
    	答：设数组的长度为n，最后一个父母结点是从头开始数的第n/2-1的那个数（可以自己画一个图去求证）
    	这就解释了为什么设立大根堆是从i=n/2-1开始着手
    	
    	理解了堆的概念就可以想到，堆的构建有点类似递归的形式，是类似
    	即从下往上，对于每个结点都进行堆的构建，而正是这种递归，才使我们可以找到当前堆的最大值
    */
    void heap_sort(int a[], int n)
    {	
        /*对于传入的数组，先建立大根堆*/
    	for (int i = n / 2 - 1; i >= 0; i -- ) HeapAdjust(a, i, n);
    
        /*
        	因为建立的是大根堆，所以，当前数组的最大值肯定就是第一个，因此就把第一个数字放到数组的最后一位
        	然后再对前0-n-1个数字建立新的大根堆
        	依此类推
        */
        for (int i = n - 1; i > 0; i -- ){
            swap(a[0], a[i]);
            HeapAdjust(a, 0, i);
        }
    }
    ```

  - 

- 分析是否为稳定排序、时间复杂度的推导、时间和空间复杂度

  - 非稳定排序
  - 时间复杂度：最好最坏平均都是O(nlogn)
  - 空间复杂度：O(1)





### Others

- 对于有序的数据，那种排序算法比较有序
  - 冒泡排序和插入排序，在有序数据的情况下都是O(n)
- 计数排序可以做到在数据稠密的时候O（n）的排序
- 稳定性、时间复杂度和空间复杂度的定义



## 题目

- 215. 数组中的第K个最大元素
- 剑指 Offer 40. 最小的k个数
- 912. 排序数组
- topk问题



### 归并排序

- 23. 合并K个升序链表



### 堆排序

- Top K

- 打印n个数组中最大的topk（https://blog.csdn.net/u013309870/article/details/70196537）
