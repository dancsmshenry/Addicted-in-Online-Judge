# QuickSort

- 快速排序的实现（递归和非递归的版本，传统递归，非递归的需要用到栈）
- 分析是否为稳定排序、时间复杂度的推导、时间和空间复杂度（平均、最好（nlogn）和最坏（n^2）情况下的）
- 快速排序的优化

  - 在选择哨兵的时候使用三数取中法，即取序列第一个元素、中间元素以及最后一个元素，在取这三个元素的中位数作为哨兵，可以避免取到边缘值而导致每次分割不均匀的情况
  - 因为在递归分割序列时，序列的长度会越来越短，又因为短序列排序中插入排序效率最高，所以可以设置一个阈值，当序列长度分割到阈值时切换到插入排序，提高效率
  - 当序列中存在大量相同元素，或者全是相同元素时，使用快排仍然会得到最低效率，这时可以采用聚集相等元素的方法，每次选择哨兵后，将与哨兵相同的元素放到序列中间，下次分割时中间这些值不参与分割
  - 当递归层数过深的时候改用堆排序，虽然第一个优化方法避免了取到边缘哨兵，但还是有可能取到较边缘的哨兵，最坏的情况会导致递归层数过深，从而降低快排效率，所以每次递归要判断递归层数，达到一定深度就改用堆排序，这是stl源码里实现的方法。之所以要用堆排序，我猜想可能是因为快排和归并都是基于递归的排序，此时递归深度已经太深，肯定不能再用了，而对于较长的序列使用插入排序效率也不是太高，所以选择了堆排序





# BubbleSort

- 冒泡排序的实现
- 分析是否为稳定排序、时间复杂度的推导、时间和空间复杂度（平均、最好和最坏情况下的）
- 冒泡排序的优化
  - 每一次二级循环都放置一个哨兵，如果flag不变，则说明有序，就不要继续排序了





# MergeSort

- 归并排序的实现
- 分析是否为稳定排序、时间复杂度的推导、时间和空间复杂度（平均、最好和最坏情况下的）





# HeapSort

- 堆排序的实现
- 分析是否为稳定排序、时间复杂度的推导、时间和空间复杂度（平均、最好和最坏情况下的）





# Others

- 对于有序的数据，那种排序算法比较有序
  - 冒泡排序和插入排序，在有序数据的情况下都是O(n)
- 计数排序可以做到在数据稠密的时候O（n）的排序
- 稳定性、时间复杂度和空间复杂度的定义
- 打印n个数组中最大的topk（https://blog.csdn.net/u013309870/article/details/70196537）
