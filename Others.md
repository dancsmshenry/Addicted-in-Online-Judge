# 目录

### Top K

- 打印n个数组中最大的topk（https://blog.csdn.net/u013309870/article/details/70196537）



### 快速幂

- 剑指offer 14- II.剪绳子 II



### 约瑟夫环

- 剑指offer 62.圆圈中最后剩下的数字

- ```cpp
  int solve(int n, int m){
      if (n == 1){
          return 0;
      }else{
          return (solve(n - 1, m) + m) % n;
      }
  }
  ```



### 拓扑排序

- 例题：课程表，课程表II
- 这类题其实有点像模板题，乍一看有点不明来路，但是经过可以训练后是可以达到效果的
- 思路如下：用一个一维数组记录该点的先修课（入度），再用一个二维数组，对于每节课，学了这节课，可以学哪些课
- 然后再把入度为0的课程放入一个队列中（入度为0，表示这节课可以直接上，不需要先修课）
- 然后遍历队列，遍历到的课就是上过了的，然后对那些先修课又这节课的课程，减一他们的入度
- 接着判断入度是否为0，如果是，就代表可以学习了，就把他放入队列中
- 直到队列中没有元素，最后判断



### LRU和LFU

- 460.lfu缓存



### 实现tire树

- 建立结点tirenode，包含一个指向该结点的数组和一个bool值，布尔值是用来判断是否存在以该节点为末的单词
- 然后依次实现插入，查询单词，查询前缀的操作
- 这道题没啥好说的，注意细节就行了



### 蓄水池抽样法

- 挖坑（https://blog.csdn.net/weixin_41481113/article/details/83449009）



### 鸡蛋楼梯问题

- 挖坑（非常经典的google面试题）



### 实现优先队列

- 挖坑



### 字符串匹配算法

- 挖坑（28、实现strstr，实现kmp算法）



### 高精度加减乘除

- 挖坑（字符串相乘：大数相乘，模拟，注意细节）
- 415、字符串相加（高精度加法）



### rand7()生成rand10()

- leetcode 430 Rand7实现Rand10（ys面wxg的时候遇见的）

- https://imageslr.com/2020/probility-lc430.html#randm-%E7%94%9F%E6%88%90-randn

- 我对这道题的理解，这道题的思路上主要分为两步

- 第一步：从rand10()生成rand7()，方法是：我们只要不断调用 rand10() 即可，直到得到我们要的数

- 解释：第一次出现1-7的数字的概率是7/10，第二次的时候，第一次没有命中，第二次命中了，就是3*7/100，依次类推，就是一个等比公式，求到最后发现，得到rand7中的前7个数字的概率是7 / 10 * 10 / 7，即用过rand10的不断调用（大于7就pass，小于等于7就用），发现得到1-7之间的数字的概率是1，那平摊到每个数字的概率就是1/7，也就是等概率的抽取了

- 结论：如果我们知道rand大的概率，那么rand小的概率也可以直接得到

- 第二步：从rand7()生成rand10()，方法是(randx() - 1) * y + randy()

- 解释：本质上是p(ab) = p(a) * p(b)，设这里的a事件为{0，7，14，21，28，35，42}，b事件为{1，2，3，4，5，6，7}，ab事件则为a事件里面的数和b事件里面的数相加得到的

- 首先确定，两个事件是互不影响的，其次，对于a事件，可以用(randx() - 1) * y实现，其中x为7，y为7；对于b事件，直接是randy()，其中y为7

- 注意，这里也可以换为(randx() - 1) * y + randy() - 1，因为后面randy()- 1得到的也是y个数字......，不过是0-x*y-1

- 优化：最开始的优化：对于rand7生成rand10，如果生成的数字是1-40之间，就直接return x%10 + 1

- 接着优化：而这里还有41-49没有用上，此时就可以再来一遍

- 看了上述的blog之后，有一个快速好记的理解方式：通过m进制的想法，每执行依次randm，就得到一个0-m-1的数字，对应到位置上，后续再把它转化到十进制，即乘以m的零次方，一次方，二次方，三次方，四次方

  - 已知 RandM() 可以等概率的生成 [0, M-1] 范围的随机整数，那么执行 k 次，每次都得到 M 进制的一位，可以等概率生成 [0,Mk−1] 范围的随机整数，记为 x 
  - RandN 至少需要 N 个均匀随机整数，因此只需要取 k，使得 Mk−1>=N 即可 
  - 此时有多种方式得到 RandN： 
  - 一种是只在 x∈[0,N−1] 时返回 x 
  - 另一种是利用取余运算，在保证等概率的前提下，尽可能多的利用生成的数字，从而减少舍弃的数字比例，降低 while 重复执行的概率

- ```cpp
  int x = (rand7() - 1) * 7 + (rand7() - 1); // 0~48
  
  if (x >= 1 && x <= 40) return x % 10 + 1;
  
  x = (x % 40) * 7 + rand7(); // 1~63
  if (x <= 60) return x % 10 + 1;
  ```

- 再来一遍优化，因为61 62 63没有用上，所以来一遍1-21

- 拓展：[📝【LeetCode】430. Rand7 实现 Rand10 (imageslr.com)](https://imageslr.com/2020/probility-lc430.html#rand7-生成-rand10)建议反复观看



### 字节面试题

- 在脉脉上看到的

  - 题干：给定一个整型数组，在数组中找出由三个数组成的最大乘积
  - 题解：找min1,min2,max1,max2,max3，最大数要么就是max1 * max2 * max3，要么就是max3 * min1 * min2
- ys面试遇到的
  - 题干：把数字转换为中文：100001，转换为十万零一



### 杂题（12.12）

- 709.转换成小写字母
  - 可以直接调用api来写
  - 但是也发现了ascii码的一个规律，就是为什么大写字母和小写字母之间要加上6个多余的符号：因为这样刚好一个字母的大写和小写就会差32，即如果知道一个字母的大写，那么把它转换为二进制然后再在他的特定位置上加上1，就是小写了



### 杂题（12.13）

- 239.滑动窗口的最大值（leetcode给的第三种题解，对数组进行预处理，很富有思想深度的一种解法）



### 杂题（12.18）

- 419 甲板上的战舰：可以用dfs，不过由于题目的要求，只需要遍历一次就可以了
- 128 最长连续序列：hash解决，先遍历全部一遍，然后假设每个数都可能是最后一个，接着开始不断+1+1的往后找



### 杂题（12.23）

- 剑指offer67.把字符串转换成整数：这道题把，就是不断的完善题目的各种边界情况，不断的思考犯错改进
  - 用flag判断，如果flag为true则证明是还没接触到数字；false就代表接触到了数字
  - 如果一开始遇到空格，flag为true，就跳过
  - 如果flag为false，又不是数字，就直接退出（因为前面遇到了数字，已经处理完了）
  - 如果是正号或负号，且后面还是数字（注意，此时flag应该是true，因为是false的话在上一步就break了），就处理fuhao
  - 如果flag为true，且当前是字母或符号，则break
  - 最后处理数字
  - 数字比较麻烦的就是可能会越界，所以要判断一下
- 剑指offer66.构建乘积数组
  - 需要注意一下有多个零的情况



### 杂题（12.24）

- 字符串解码
  - 详情看代码吧，我用的是循环加递归的方法，代码讲得挺详细的
- 丑数II（剑指offer 49）
  - 三指针，动态规划，对于dp[i]，每次都选择最小的，然后后移指针
  - 证明过程复杂，建议直接朗诵吧
- 队列的最大值（剑指offer 59）
  - 这道题和滑动窗口的最大值是一模一样的
  - 题目意思：维护一个队列，但同时要能够找到当前队列的最大值
  - 就是用一个双向队列去维护队列的最大值，该双向队列比我大，我就把元素踢出；比我小，就把元素放入
  - 踢出元素的时候，注意一下是不是当前元素即可，是的话就一并踢出



### 杂题（12.28）

- 下一个排列



### 杂题（12.30）

- 第n位数字



### 杂题（01.16）

- 150、逆波兰表达式：对一个算术表达式进行左右根的排序，然后求其值（用栈来解决）
- 36、有效的数独：对每行每列进行判断，然后再对每个3*3的方阵判断
- 93、复原IP地址：经典回溯
- 445、两数相加II：模拟加法
- 912、排序数组：快排+随机选取中间点



### 杂题（01.17）

- 第三大的数：模拟
- 二进制求和：模拟



### 杂题（01.20）

- 22、括号生成：回溯
- 165、比较版本号：字符串处理，以后要多看看字符串，一遇到这个就短路....
- 242、有效的字母异位词：杂题



### 杂题（01.21）

- 387、字符串中的第一个唯一字符：模拟



### 杂题（01.22）

- 面试题 01.06.字符串压缩：双指针模拟，然后比较大小
- 面试题 01.02.判定是否互为字符重排：模拟+hash
- 454.四数相加 II：利用hash降低了复杂度（感觉自己有的时候不是很能发现题目到底该用那些方法..，有点笨了）



### 杂题（01.23）

- 简化路径：又是字符串，模拟试错（不过看到了官方的题解就觉得很不错，先用一个split函数把路径分成多块，然后再分批处理，看来字符串的题目还是要多多学习一下）



### 杂题（01.24）

- 171.Excel 表列序号：26进制，模拟即可



### 杂题（01.25）

- 递增的三元子序列（有点智商题的味道，和求第三大的数的那道题很像）
- 最大数（数学证明比较繁琐，不过后续还是要注意一下lambda的用法了，太好用了啊）
- 两数相除（有点智商题的味道，一开始没看懂，不过很经典，适合后面好好品味品味啊）



### 杂题（01.27）

- 今天见识到了排序+贪心/dp这套组合拳的威力了，是真的厉害，特别是二分贪心这种做法，真的很不错
  - 最长子序列：dp（容易超时），二分+贪心（很好很聪明的方法，值得反复品味）
  - 俄罗斯套娃信封问题（同上的套路，不过要熟悉一下lambda，sort，等函数的用法）
  - 无重叠区间：dp or 贪心（非常的好用）
  - 最长数对链：同上
  - 用最少数量箭引爆气球：同上
  - 对箱子：俄罗斯套娃



### 杂题（01.28）

- 划分字母区间（非常有意思的贪心做法，真的是对题目的意思理解的非常的透彻才会想到这种方法）
- 验证IP地址（字符串的基本模拟）



### review（02.13）

- 今天听群友说的一道题，一时半会没想出来怎么做，来分享一下
- 和为k的子数组
  - 方法一使用前缀和，然后再来个双循环遍历，时间复杂度太高了
  - 方法二前缀和+hashmap，用一个循环来写前缀和，然后用hashmap来记录前缀和，注意，这里的值每次都+1，接着判断是否存在以当前数字为尾的子数组，使得其和为target，设当前的数字是pre，即求是否前面的前缀和存在pre-target的情况



# 剑指review

### 02.13（5题）

- 03、数组中的重复的数字

  - 可以排序，可以哈希表，可以set
  - 但是原地哈希这种做法值得好好反思一下

- 04、二维数组中的查找

  - 经典的二分查找，从右上或左下都可以进行查询
  - 二分法，其本质其实是进行分割后的两边一样可以再用这种方法进行分割
  - 看到**查找**就要条件反射为**二分查找**

- 05、替换空格

  - 注意一下扩容后原地替换的写法，有点意思

- 06、从尾到头打印链表

  - 栈，先进后出 or 放入再倒序

  - 在评论区还看到递归的做法，有点意思

  - ```cpp
    class Solution {
    public:
        vector<int> reversePrint(ListNode* head) {
            if(!head)
                return {};
            vector<int> a=reversePrint(head->next);
            a.push_back(head->val);
            return a;
        }
    };
    ```

  - 让我想到了反转链表那道题也是一样可以用递归来实现，有点炫技，不过值得参考

- 07、重建二叉树

  - 多的不说了，由前中或中后来推导二叉树，默写就完事了！！！！



# 总结

- 发现字节很喜欢考leetcode的变种题，就是把两道leetcode组合在一起，非常的考验做题家的总结和应对能力
- 还有，有些题目（求两数组的中位数）其实在自己训练的时候，是要自己动脑筋去想去理解的，但是对于面试来说，其实只需要朗诵即可....（虽然听起来很功利，但是对于我这种能力不太行的人来说，是这样的...）
- 有关类型的api，建议都用cppreference去查
- 学会看leetcode的报错！！
- https://leetcode-cn.com/circle/discuss/qJXzLU/
