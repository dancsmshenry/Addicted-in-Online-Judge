# 目录

### 约瑟夫环

- 剑指offer 62.圆圈中最后剩下的数字

- ```cpp
  int solve(int n, int m){
      if (n == 1){
          return 0;
      }else{
          return (solve(n - 1, m) + m) % n;
      }
  }
  ```



### 快速幂

- 剑指offer 14- II.剪绳子 II



### 709.转换成小写字母

- 可以直接调用api来写
- 但是也发现了ascii码的一个规律，就是为什么大写字母和小写字母之间要加上6个多余的符号：因为这样刚好一个字母的大写和小写就会差32，即如果知道一个字母的大写，那么把它转换为二进制然后再在他的特定位置上加上1，就是小写了



### 239.滑动窗口的最大值

- leetcode给的第三种题解，对数组进行预处理，很富有思想深度的一种解法



### 鸡蛋楼梯问题

- 非常经典的google面试题



### 字节面试题

- 是在脉脉上看到的

- 题干：给定一个整型数组，在数组中找出由三个数组成的最大乘积
- 题解：找min1,min2,max1,max2,max3，最大数要么就是max1 * max2 * max3，要么就是max3 * min1 * min2



### rand7()生成rand10()

- leetcode 430 Rand7实现Rand10（ys面wxg的时候遇见的）

- https://imageslr.com/2020/probility-lc430.html#randm-%E7%94%9F%E6%88%90-randn

- 我对这道题的理解，这道题的思路上主要分为两步

- 第一步：从rand10()生成rand7()，方法是：我们只要不断调用 rand10() 即可，直到得到我们要的数

- 解释：第一次出现1-7的数字的概率是7/10，第二次的时候，第一次没有命中，第二次命中了，就是3*7/100，依次类推，就是一个等比公式，求到最后发现，得到rand7中的前7个数字的概率是7 / 10 * 10 / 7，即用过rand10的不断调用（大于7就pass，小于等于7就用），发现得到1-7之间的数字的概率是1，那平摊到每个数字的概率就是1/7，也就是等概率的抽取了

- 结论：如果我们知道rand大的概率，那么rand小的概率也可以直接得到

- 第二步：从rand7()生成rand10()，方法是(randx() - 1) * y + randy()

- 解释：本质上是p(ab) = p(a) * p(b)，设这里的a事件为{0，7，14，21，28，35，42}，b事件为{1，2，3，4，5，6，7}，ab事件则为a事件里面的数和b事件里面的数相加得到的

- 首先确定，两个事件是互不影响的，其次，对于a事件，可以用(randx() - 1) * y实现，其中x为7，y为7；对于b事件，直接是randy()，其中y为7

- 注意，这里也可以换为(randx() - 1) * y + randy() - 1，因为后面randy()- 1得到的也是y个数字......，不过是0-x*y-1

- 优化：最开始的优化：对于rand7生成rand10，如果生成的数字是1-40之间，就直接return x%10 + 1

- 接着优化：而这里还有41-49没有用上，此时就可以再来一遍

- 看了上述的blog之后，有一个快速好记的理解方式：通过m进制的想法，每执行依次randm，就得到一个0-m-1的数字，对应到位置上，后续再把它转化到十进制，即乘以m的零次方，一次方，二次方，三次方，四次方

  - 已知 RandM() 可以等概率的生成 [0, M-1] 范围的随机整数，那么执行 k 次，每次都得到 M 进制的一位，可以等概率生成 [0,Mk−1] 范围的随机整数，记为 x 
  - RandN 至少需要 N 个均匀随机整数，因此只需要取 k，使得 Mk−1>=N 即可 
  - 此时有多种方式得到 RandN： 
  - 一种是只在 x∈[0,N−1] 时返回 x 
  - 另一种是利用取余运算，在保证等概率的前提下，尽可能多的利用生成的数字，从而减少舍弃的数字比例，降低 while 重复执行的概率

- ```cpp
  int x = (rand7() - 1) * 7 + (rand7() - 1); // 0~48
  
  if (x >= 1 && x <= 40) return x % 10 + 1;
  
  x = (x % 40) * 7 + rand7(); // 1~63
  if (x <= 60) return x % 10 + 1;
  ```

- 再来一遍优化，因为61 62 63没有用上，所以来一遍1-21

- 拓展：[📝【LeetCode】430. Rand7 实现 Rand10 (imageslr.com)](https://imageslr.com/2020/probility-lc430.html#rand7-生成-rand10)建议反复观看



### LRU和LFU

- 参考460 lfu缓存



### Top k

- 打印n个数组中最大的topk（https://blog.csdn.net/u013309870/article/details/70196537）



### 实现优先队列



### 杂题两道（12.18）

- 419 甲板上的战舰：可以用dfs，不过由于题目的要求，只需要遍历一次就可以了
- 128 最长连续序列：hash解决，先遍历全部一遍，然后假设每个数都可能是最后一个，接着开始不断+1+1的往后找



### 字节面试题

- 把数字转换为中文：100001，转换为十万零一



### 杂题数道

- 剑指offer67.把字符串转换成整数：这道题把，就是不断的完善题目的各种边界情况，不断的思考犯错改进
  - 用flag判断，如果flag为true则证明是还没接触到数字；false就代表接触到了数字
  - 如果一开始遇到空格，flag为true，就跳过
  - 如果flag为false，又不是数字，就直接退出（因为前面遇到了数字，已经处理完了）
  - 如果是正号或负号，且后面还是数字（注意，此时flag应该是true，因为是false的话在上一步就break了），就处理fuhao
  - 如果flag为true，且当前是字母或符号，则break
  - 最后处理数字
  - 数字比较麻烦的就是可能会越界，所以要判断一下
- 剑指offer66.构建乘积数组
  - 需要注意一下有多个零的情况
- 剑指 30 包含min函数的栈
  - 很巧妙的解答方式，维护两个栈，一个用来存储入栈的值，另一个在每次pop和push的时候，处理最小值，如果push的比当前最小值的栈还要小的值，就同时把它放入最小栈；pop的时候，如果当前的值等于stack2的top，也踢出（感觉有点像模板题，背下来，面试的时候吟诵背后理论即可）



### 杂题数道（12.24）

- 实现tire树
  - 建立结点tirenode，包含一个指向该结点的数组和一个bool值，布尔值是用来判断是否存在以该节点为末的单词
  - 然后依次实现插入，查询单词，查询前缀的操作
  - 这道题没啥好说的，注意细节就行了
- 字符串解码
  - 详情看代码吧，我用的是循环加递归的方法，代码讲得挺详细的
- 丑数II（剑指offer 49）
  - 三指针，动态规划，对于dp[i]，每次都选择最小的，然后后移指针
  - 证明过程复杂，建议直接朗诵吧
- 队列的最大值（剑指offer 59）
  - 这道题和滑动窗口的最大值是一模一样的
  - 题目意思：维护一个队列，但同时要能够找到当前队列的最大值
  - 就是用一个双向队列去维护队列的最大值，该双向队列比我大，我就把元素踢出；比我小，就把元素放入
  - 踢出元素的时候，注意一下是不是当前元素即可，是的话就一并踢出



### 拓扑排序

- 课程表，课程表II
- 这类题其实有点像模板题，乍一看有点不明来路，但是经过可以训练后是可以达到效果的
- 思路如下：用一个一维数组记录该点的先修课（入度），再用一个二维数组，对于每节课，学了这节课，可以学哪些课
- 然后再把入度为0的课程放入一个队列中（入度为0，表示这节课可以直接上，不需要先修课）
- 然后遍历队列，遍历到的课就是上过了的，然后对那些先修课又这节课的课程，减一他们的入度
- 接着判断入度是否为0，如果是，就代表可以学习了，就把他放入队列中
- 直到队列中没有元素，最后判断



### 杂题

- 下一个排列



# 总结

- 发现字节很喜欢考leetcode的变种题，就是把两道leetcode组合在一起，非常的考验做题家的总结和应对能力
- [刷题交流｜有没有一样的盆友 力扣上的题做的挺多了 做大厂笔试题还是觉得好难 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/circle/discuss/qJXzLU/)
- 还有，有些题目（求两数组的中位数）其实在自己训练的时候，是要自己动脑筋去想去理解的，但是对于面试来说，其实只需要朗诵即可....（虽然听起来很功利，但是对于我这种能力不太行的人来说，是这样的...）





# 有关leetcode做题中发现的问题

- 有关类型的api，建议都用cppreference去查

- ```cpp
  Line 29: Char 21: runtime error: member access within misaligned address 0xbebebebebebebebe for type ‘struct TreeNode’, which requires 8 byte alignment (solution.cpp)
  0xbebebebebebebebe: note: pointer points here
      //这个报错，一般是用了空指针，或者，是写成了TreeNode* node = new TreeNode;（少了个括号....）
  ```

- 
