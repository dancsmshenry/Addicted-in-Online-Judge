# 目录

- 约瑟夫环
  - 剑指offer 62.圆圈中最后剩下的数字
  
  - ```cpp
    int solve(int n, int m){
        if (n == 1){
            return 0;
        }else{
            return (solve(n - 1, m) + m) % n;
        }
    }
    ```
  
  - 
  
- 快速幂
  - 剑指offer 14- II.剪绳子 II
  
- 709.转换成小写字母
  - 可以直接调用api来写
  - 但是也发现了ascii码的一个规律，就是为什么大写字母和小写字母之间要加上6个多余的符号：因为这样刚好一个字母的大写和小写就会差32，即如果知道一个字母的大写，那么把它转换为二进制然后再在他的特定位置上加上1，就是小写了
  
- 239.滑动窗口的最大值
  - leetcode给的第三种题解，对数组进行预处理，很富有思想深度的一种解法
  
- 谷歌的鸡蛋楼梯问题

- 又是一道字节题目
  - 给定一个整型数组，在数组中找出由三个数组成的最大乘积
  - 找min1,min2,max1,max2,max3，最大数要么就是max1 * max2 * max3，要么就是max3 * min1 * min2
  
- 经典面试题（ys面wxg的时候遇见的）
  - leetcode 430 Rand7实现Rand10
  
  - https://imageslr.com/2020/probility-lc430.html#randm-%E7%94%9F%E6%88%90-randn
  
  - 我对这道题的理解，这道题的思路上主要分为两步
  
  - 第一步：从rand10()生成rand7()，方法是：我们只要不断调用 rand10() 即可，直到得到我们要的数
  
  - 解释：第一次出现1-7的数字的概率是7/10，第二次的时候，第一次没有命中，第二次命中了，就是3*7/100，依次类推，就是一个等比公式，求到最后发现，得到rand7中的前7个数字的概率是7 / 10 * 10 / 7，即用过rand10的不断调用（大于7就pass，小于等于7就用），发现得到1-7之间的数字的概率是1，那平摊到每个数字的概率就是1/7，也就是等概率的抽取了
  
  - 结论：如果我们知道rand大的概率，那么rand小的概率也可以直接得到
  
  - 第二步：从rand7()生成rand10()，方法是(randx() - 1) * y + randy()
  
  - 解释：本质上是p(ab) = p(a) * p(b)，设这里的a事件为{0，7，14，21，28，35，42}，b事件为{1，2，3，4，5，6，7}，ab事件则为a事件里面的数和b事件里面的数相加得到的
  
  - 首先确定，两个事件是互不影响的，其次，对于a事件，可以用(randx() - 1) * y实现，其中x为7，y为7；对于b事件，直接是randy()，其中y为7
  
  - 注意，这里也可以换为(randx() - 1) * y + randy() - 1，因为后面randy()- 1得到的也是y个数字......，不过是0-x*y-1
  
  - 优化：最开始的优化：对于rand7生成rand10，如果生成的数字是1-40之间，就直接return x%10 + 1
  
  - 接着优化：而这里还有41-49没有用上，此时就可以再来一遍
  
  - 看了上述的blog之后，有一个快速好记的理解方式：通过m进制的想法，每执行依次randm，就得到一个0-m-1的数字，对应到位置上，后续再把它转化到十进制，即乘以m的零次方，一次方，二次方，三次方，四次方
  
    - 已知 RandM() 可以等概率的生成 [0, M-1] 范围的随机整数，那么执行 k 次，每次都得到 M 进制的一位，可以等概率生成 [0,Mk−1] 范围的随机整数，记为 x 
    - RandN 至少需要 N 个均匀随机整数，因此只需要取 k，使得 Mk−1>=N 即可 
    - 此时有多种方式得到 RandN： 
    - 一种是只在 x∈[0,N−1] 时返回 x 
    - 另一种是利用取余运算，在保证等概率的前提下，尽可能多的利用生成的数字，从而减少舍弃的数字比例，降低 while 重复执行的概率
  
  - ```cpp
    int x = (rand7() - 1) * 7 + (rand7() - 1); // 0~48
    
    if (x >= 1 && x <= 40) return x % 10 + 1;
    
    x = (x % 40) * 7 + rand7(); // 1~63
    if (x <= 60) return x % 10 + 1;
    ```
  
  - 再来一遍优化，因为61 62 63没有用上，所以来一遍1-21
  
- 概率硬币题目：[📝【LeetCode】430. Rand7 实现 Rand10 (imageslr.com)](https://imageslr.com/2020/probility-lc430.html#rand7-生成-rand10)建议反复观看

- 经典操作系统算法题：LRU和LFU

  - 参考460 lfu缓存

- 经典面试题
  - 打印n个数组的topk
  
- 怎样实现优先队列



# 总结

- 发现字节很喜欢考leetcode的变种题，就是把两道leetcode组合在一起，非常的考验做题家的总结和应对能力

- [刷题交流｜有没有一样的盆友 力扣上的题做的挺多了 做大厂笔试题还是觉得好难 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/circle/discuss/qJXzLU/)
